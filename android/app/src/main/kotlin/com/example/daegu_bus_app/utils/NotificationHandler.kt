package com.example.daegu_bus_app.utils

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.ServiceInfo
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import com.example.daegu_bus_app.services.BusAlertService
import com.example.daegu_bus_app.MainActivity
import com.example.daegu_bus_app.R

class NotificationHandler(private val context: Context) {

    companion object {
        private const val TAG = "NotificationHandler"

        // Notification Channel IDs
        private const val CHANNEL_ID_ONGOING = "bus_tracking_ongoing"
        private const val CHANNEL_NAME_ONGOING = "Ïã§ÏãúÍ∞Ñ Î≤ÑÏä§ Ï∂îÏ†Å"
        private const val CHANNEL_ID_ALERT = "bus_tracking_alert"
        private const val CHANNEL_NAME_ALERT = "Î≤ÑÏä§ ÎèÑÏ∞© ÏûÑÎ∞ï ÏïåÎ¶º"
        private const val CHANNEL_ID_ERROR = "bus_tracking_error"
        private const val CHANNEL_NAME_ERROR = "Ï∂îÏ†Å Ïò§Î•ò ÏïåÎ¶º"

        // Notification IDs
        const val ONGOING_NOTIFICATION_ID = 1 // Referenced by BusAlertService
        private const val ALERT_NOTIFICATION_ID_BASE = 1000 // Base for dynamic alert IDs
        const val ARRIVING_SOON_NOTIFICATION_ID = 2 // For arriving soon notifications

        // Intent Actions (referenced by notifications)
        // private const val ACTION_STOP_TRACKING = "com.example.daegu_bus_app.action.STOP_TRACKING"
        private const val ACTION_CANCEL_NOTIFICATION = "com.example.daegu_bus_app.action.CANCEL_NOTIFICATION"
    }

     // --- Notification Channel Creation ---

    fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            try {
                val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

                // Ongoing Channel (Low importance, silent)
                val ongoingChannel = NotificationChannel(
                    CHANNEL_ID_ONGOING,
                    CHANNEL_NAME_ONGOING,
                    NotificationManager.IMPORTANCE_LOW // Silent, minimal interruption
                ).apply {
                    description = "Ïã§ÏãúÍ∞Ñ Î≤ÑÏä§ Ï∂îÏ†Å ÏÉÅÌÉú ÏïåÎ¶º"
                    enableVibration(false)
                    enableLights(false)
                    setShowBadge(false)
                    lockscreenVisibility = Notification.VISIBILITY_PRIVATE
                }

                // Alert Channel (High importance, sound/vibration)
                val alertChannel = NotificationChannel(
                    CHANNEL_ID_ALERT,
                    CHANNEL_NAME_ALERT,
                    NotificationManager.IMPORTANCE_HIGH // Alerting!
                ).apply {
                    description = "Î≤ÑÏä§ ÎèÑÏ∞© ÏûÑÎ∞ï Ïãú ÏïåÎ¶º"
                    enableVibration(true)
                    vibrationPattern = longArrayOf(0, 400, 200, 400)
                    lightColor = ContextCompat.getColor(context, R.color.tracking_color) // Use context
                    enableLights(true)
                    setShowBadge(true)
                    lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                }

                // Error Channel (Default importance)
                 val errorChannel = NotificationChannel(
                    CHANNEL_ID_ERROR,
                    CHANNEL_NAME_ERROR,
                    NotificationManager.IMPORTANCE_DEFAULT
                ).apply {
                    description = "Î≤ÑÏä§ Ï∂îÏ†Å Ï§ë Ïò§Î•ò Î∞úÏÉù ÏïåÎ¶º"
                    enableVibration(true)
                    setShowBadge(true)
                }

                notificationManager.createNotificationChannel(ongoingChannel)
                notificationManager.createNotificationChannel(alertChannel)
                notificationManager.createNotificationChannel(errorChannel)
                Log.d(TAG, "Notification channels created.")
            } catch (e: Exception) {
                Log.e(TAG, "Error creating notification channels: ${e.message}", e)
            }
        }
    }

    // --- Ongoing Notification ---

    fun buildOngoingNotification(activeTrackings: Map<String, BusAlertService.TrackingInfo>): Notification {
        val startTime = System.currentTimeMillis()
        val currentTimeStr = SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault()).format(Date())
        Log.d(TAG, "üîî ÏïåÎ¶º ÏÉùÏÑ± ÏãúÏûë - $currentTimeStr")

        // Í∞Å ÌôúÏÑ± Ï∂îÏ†ÅÏùò Î≤ÑÏä§ Ï†ïÎ≥¥Î•º Î°úÍ∑∏Î°ú Ï∂úÎ†•
        activeTrackings.forEach { (routeId, info) ->
            val busInfo = info.lastBusInfo
            Log.d(TAG, "üîç Ï∂îÏ†Å ÏÉÅÌÉú: ${info.busNo}Î≤à Î≤ÑÏä§, ÏãúÍ∞Ñ=${busInfo?.estimatedTime ?: "Ï†ïÎ≥¥ ÏóÜÏùå"}, ÏúÑÏπò=${busInfo?.currentStation ?: "ÏúÑÏπò Ï†ïÎ≥¥ ÏóÜÏùå"}")
        }

        val currentTime = SimpleDateFormat("HH:mm:ss", Locale.getDefault()).format(Date()) // ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ Ï¥à Îã®ÏúÑÍπåÏßÄ ÌëúÏãú
        val title = "Î≤ÑÏä§ ÏïåÎûå Ï∂îÏ†Å Ï§ë ($currentTime)"
        var contentText = "Ï∂îÏ†Å Ï§ëÏù∏ Î≤ÑÏä§: ${activeTrackings.size}Í∞ú"

        val inboxStyle = NotificationCompat.InboxStyle()
            .setBigContentTitle(title)

        if (activeTrackings.isEmpty()) {
            contentText = "Ï∂îÏ†Å Ï§ëÏù∏ Î≤ÑÏä§Í∞Ä ÏóÜÏäµÎãàÎã§."
            inboxStyle.addLine(contentText)
            Log.d(TAG, "üö´ Ï∂îÏ†Å Ï§ëÏù∏ Î≤ÑÏä§ ÏóÜÏùå")
        } else {
            Log.d(TAG, "üìä Ï∂îÏ†Å Ï§ëÏù∏ Î≤ÑÏä§ Ïàò: ${activeTrackings.size}")
            activeTrackings.values.take(5).forEach { trackingInfo ->
                val busInfo = trackingInfo.lastBusInfo
                val busNo = trackingInfo.busNo
                val stationNameShort = trackingInfo.stationName.take(10) + if (trackingInfo.stationName.length > 10) "..." else ""

                // ÏãúÍ∞Ñ Ï†ïÎ≥¥ Ï≤òÎ¶¨ Í∞úÏÑ†
                val timeStr = when {
                    busInfo == null -> "Ï†ïÎ≥¥ ÏóÜÏùå"
                    busInfo.estimatedTime == "Ïö¥ÌñâÏ¢ÖÎ£å" -> "Ïö¥ÌñâÏ¢ÖÎ£å"
                    busInfo.estimatedTime == "Í≥ß ÎèÑÏ∞©" -> "Í≥ß ÎèÑÏ∞©"
                    busInfo.estimatedTime.contains("Î∂Ñ") -> {
                        val minutes = busInfo.estimatedTime.replace("[^0-9]".toRegex(), "").toIntOrNull()
                        if (minutes != null) {
                            if (minutes <= 0) "Í≥ß ÎèÑÏ∞©" else "${minutes}Î∂Ñ"
                        } else busInfo.estimatedTime
                    }
                    busInfo.getRemainingMinutes() <= 0 -> "Í≥ß ÎèÑÏ∞©"
                    trackingInfo.consecutiveErrors > 0 -> "Ïò§Î•ò"
                    else -> busInfo.estimatedTime
                }

                // ÌòÑÏû¨ ÏúÑÏπò Ï†ïÎ≥¥ Ï∂îÍ∞Ä
                val locationInfo = if (busInfo?.currentStation != null && busInfo.currentStation.isNotEmpty()) {
                    " [ÌòÑÏû¨: ${busInfo.currentStation}]"
                } else {
                    ""
                }

                val lowFloorStr = if (busInfo?.isLowFloor == true) "(Ï†Ä)" else ""
                val infoLine = "$busNo$lowFloorStr (${stationNameShort}): $timeStr$locationInfo"
                inboxStyle.addLine(infoLine)
                Log.d(TAG, "‚ûï ÏïåÎ¶º ÎùºÏù∏ Ï∂îÍ∞Ä: $infoLine")
                Log.d(TAG, "üöç Î≤ÑÏä§ Ï†ïÎ≥¥ ÎîîÎ≤ÑÍπÖ: Î≤ÑÏä§=$busNo, ÏúÑÏπò=${busInfo?.currentStation ?: "ÏúÑÏπò ÏóÜÏùå"}, ÏãúÍ∞Ñ=$timeStr")
            }

            if (activeTrackings.size > 5) {
                inboxStyle.setSummaryText("+${activeTrackings.size - 5}Í∞ú Îçî Ï∂îÏ†Å Ï§ë")
            }

            // Ï≤´ Î≤àÏß∏ Î≤ÑÏä§ Ï†ïÎ≥¥Î•º contentTextÏóê ÌëúÏãú
            val firstTracking = activeTrackings.values.firstOrNull()
            if (firstTracking != null) {
                val busInfo = firstTracking.lastBusInfo
                val busNo = firstTracking.busNo
                val timeStr = when {
                    busInfo == null -> "Ï†ïÎ≥¥ ÏóÜÏùå"
                    busInfo.estimatedTime == "Ïö¥ÌñâÏ¢ÖÎ£å" -> "Ïö¥ÌñâÏ¢ÖÎ£å"
                    busInfo.estimatedTime == "Í≥ß ÎèÑÏ∞©" -> "Í≥ß ÎèÑÏ∞©"
                    busInfo.estimatedTime.contains("Î∂Ñ") -> {
                        val minutes = busInfo.estimatedTime.replace("[^0-9]".toRegex(), "").toIntOrNull()
                        if (minutes != null) {
                            if (minutes <= 0) "Í≥ß ÎèÑÏ∞©" else "${minutes}Î∂Ñ"
                        } else busInfo.estimatedTime
                    }
                    busInfo.getRemainingMinutes() <= 0 -> "Í≥ß ÎèÑÏ∞©"
                    firstTracking.consecutiveErrors > 0 -> "Ïò§Î•ò"
                    else -> busInfo.estimatedTime
                }

                // ÌòÑÏû¨ ÏúÑÏπò Ï†ïÎ≥¥ Ï∂îÍ∞Ä (Ï†ÑÏ≤¥ ÌëúÏãú)
                val locationInfo = if (busInfo?.currentStation != null && busInfo.currentStation.isNotEmpty()) {
                    " [${busInfo.currentStation}]"
                } else {
                    ""
                }

                contentText = "$busNo (${firstTracking.stationName.take(5)}..): $timeStr$locationInfo ${if (activeTrackings.size > 1) "+${activeTrackings.size - 1}" else ""}"
                Log.d(TAG, "üìù ÏïåÎ¶º ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏: $contentText")
            }
        }

        // NotificationCompat.BuilderÏóê setWhen Ï∂îÍ∞Ä Î∞è FLAG_ONGOING_EVENT ÌîåÎûòÍ∑∏ Ï∂îÍ∞Ä
        val notification = NotificationCompat.Builder(context, CHANNEL_ID_ONGOING)
            .setContentTitle(title)
            .setContentText(contentText)
            .setSmallIcon(R.drawable.ic_bus_notification)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setStyle(inboxStyle)
            .setContentIntent(createPendingIntent())
            .setOngoing(true)
            .setAutoCancel(false)
            .setOnlyAlertOnce(true)
            .setShowWhen(true)
            .setWhen(System.currentTimeMillis())
            .setColor(ContextCompat.getColor(context, R.color.tracking_color))
            .setColorized(true)
            .addAction(R.drawable.ic_stop_tracking, "Ï∂îÏ†Å Ï§ëÏßÄ", createStopPendingIntent())
            .build()

        // ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò ÌîåÎûòÍ∑∏ ÏßÅÏ†ë ÏÑ§Ï†ï - Ìï≠ÏÉÅ ÏµúÏã† Ï†ïÎ≥¥Î°ú ÌëúÏãúÎêòÎèÑÎ°ù Ìï®
        notification.flags = notification.flags or Notification.FLAG_ONGOING_EVENT or Notification.FLAG_NO_CLEAR or Notification.FLAG_FOREGROUND_SERVICE

        val endTime = System.currentTimeMillis()
        Log.d(TAG, "‚úÖ ÏïåÎ¶º ÏÉùÏÑ± ÏôÑÎ£å - ÏÜåÏöîÏãúÍ∞Ñ: ${endTime - startTime}ms, ÌòÑÏû¨ ÏãúÍ∞Ñ: $currentTime")

        Log.d(TAG, "buildOngoingNotification: ${activeTrackings.mapValues { it.value.lastBusInfo }}")

        // ÎîîÎ≤ÑÍπÖ: ÏÉùÏÑ±Îêú ÏïåÎ¶º ÎÇ¥Ïö© Î°úÍπÖ
        try {
            val extras = notification.extras
            Log.d(TAG, "üìù ÏÉùÏÑ±Îêú ÏïåÎ¶º ÎÇ¥Ïö© ÌôïÏù∏:")
            Log.d(TAG, "  Ï†úÎ™©: ${extras.getString(Notification.EXTRA_TITLE)}")
            Log.d(TAG, "  ÎÇ¥Ïö©: ${extras.getString(Notification.EXTRA_TEXT)}")

            // InboxStyle ÎÇ¥Ïö© Î°úÍπÖ
            val lines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES)
            if (lines != null) {
                Log.d(TAG, "  ÌôïÏû• ÎÇ¥Ïö© (${lines.size}Ï§Ñ):")
                lines.forEachIndexed { i, line -> Log.d(TAG, "    $i: $line") }
            }
        } catch (e: Exception) {
            Log.e(TAG, "ÏïåÎ¶º ÎÇ¥Ïö© Î°úÍπÖ Ï§ë Ïò§Î•ò: ${e.message}")
        }

        return notification
    }

    private fun createPendingIntent(): PendingIntent? {
        val openAppIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)?.apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        return if (openAppIntent != null) {
            PendingIntent.getActivity(
                context, 0, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
        } else null
    }

    private fun createStopPendingIntent(): PendingIntent {
        val stopAllIntent = Intent(context, BusAlertService::class.java).apply {
            action = BusAlertService.ACTION_STOP_TRACKING
            flags = Intent.FLAG_ACTIVITY_NEW_TASK
        }
        return PendingIntent.getService(
            context, 1, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
    }

     // --- Alert Notification ---

     fun sendAlertNotification(routeId: String, busNo: String, stationName: String, isAutoAlarm: Boolean = false) {
        val notificationId = ALERT_NOTIFICATION_ID_BASE + routeId.hashCode()
        val contentText = "$busNo Î≤à Î≤ÑÏä§Í∞Ä $stationName Ï†ïÎ•òÏû•Ïóê Í≥ß ÎèÑÏ∞©Ìï©ÎãàÎã§."
        Log.d(TAG, "Sending ALERT notification: $contentText (ID: $notificationId)")

        val openAppIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
        val pendingIntent = if (openAppIntent != null) PendingIntent.getActivity(
            context, notificationId, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        ) else null

        // ÏàòÏ†ï: ACTION_STOP_SPECIFIC_ROUTE_TRACKING ÏÇ¨Ïö©ÌïòÏó¨ ÌäπÏ†ï ÏïåÎûåÎßå Ìï¥Ï†ú
        val cancelIntent = Intent(context, BusAlertService::class.java).apply {
             action = BusAlertService.ACTION_STOP_SPECIFIC_ROUTE_TRACKING
             putExtra("routeId", routeId)
             putExtra("busNo", busNo)
             putExtra("stationName", stationName)
             putExtra("notificationId", notificationId)
             if (isAutoAlarm) putExtra("isAutoAlarm", true) // ÏûêÎèôÏïåÎûåÏù¥Î©¥ ÌîåÎûòÍ∑∏ Ï∂îÍ∞Ä
         }
         val cancelPendingIntent = PendingIntent.getService(
             context, notificationId + 1, cancelIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
         )

        val builder = NotificationCompat.Builder(context, CHANNEL_ID_ALERT)
            .setContentTitle("Î≤ÑÏä§ ÎèÑÏ∞© ÏûÑÎ∞ï!")
            .setContentText(contentText)
            .setSmallIcon(R.drawable.ic_bus_notification)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_ALARM)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
             .setColor(ContextCompat.getColor(context, R.color.alert_color)) // Use context
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)
            .addAction(R.drawable.ic_cancel, "Ï¢ÖÎ£å", cancelPendingIntent)
            .setDefaults(NotificationCompat.DEFAULT_ALL)

        val notificationManager = NotificationManagerCompat.from(context)
        notificationManager.notify(notificationId, builder.build())
    }

     // --- Error Notification ---

     fun sendErrorNotification(routeId: String?, busNo: String?, stationName: String?, message: String) {
        val notificationId = ALERT_NOTIFICATION_ID_BASE + (routeId ?: "error").hashCode() + 1
        val title = "Î≤ÑÏä§ Ï∂îÏ†Å Ïò§Î•ò"
        var contentText = message
        if (!busNo.isNullOrEmpty() && !stationName.isNullOrEmpty()) {
             contentText = "$busNo ($stationName): $message"
        }
         Log.w(TAG, "Sending ERROR notification: $contentText (ID: $notificationId)")

         val openAppIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
         val pendingIntent = if (openAppIntent != null) PendingIntent.getActivity(
             context, notificationId, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
         ) else null

         val builder = NotificationCompat.Builder(context, CHANNEL_ID_ERROR)
             .setContentTitle(title)
             .setContentText(contentText)
             .setSmallIcon(R.drawable.ic_bus_notification) // Consider an error icon
             .setPriority(NotificationCompat.PRIORITY_DEFAULT)
             .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
             .setContentIntent(pendingIntent)
             .setAutoCancel(true)

         val notificationManager = NotificationManagerCompat.from(context)
         notificationManager.notify(notificationId, builder.build())
     }

     // --- Notification Cancellation ---

     fun cancelNotification(id: Int) {
         Log.d(TAG, "Request to cancel notification ID: $id")
         try {
             val notificationManager = NotificationManagerCompat.from(context)
             notificationManager.cancel(id)

             // ÏßÑÌñâ Ï§ëÏù∏ Ï∂îÏ†Å ÏïåÎ¶ºÏù∏ Í≤ΩÏö∞ BusAlertServiceÏóêÎèÑ ÏïåÎ¶º
             if (id == ONGOING_NOTIFICATION_ID) {
                 // 1. Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå
                 try {
                     val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                     notificationManager.cancel(ONGOING_NOTIFICATION_ID)
                     notificationManager.cancelAll()
                     Log.d(TAG, "Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å")
                 } catch (e: Exception) {
                     Log.e(TAG, "Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                 }

                 // 2. ÏÑúÎπÑÏä§Ïóê Ï§ëÏßÄ ÏöîÏ≤≠ Ï†ÑÏÜ°
                 val stopIntent = Intent(context, BusAlertService::class.java).apply {
                     action = BusAlertService.ACTION_STOP_TRACKING
                     flags = Intent.FLAG_ACTIVITY_NEW_TASK
                 }
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                     context.startForegroundService(stopIntent)
                 } else {
                     context.startService(stopIntent)
                 }
                 Log.d(TAG, "Sent stop tracking request to BusAlertService")

                 // 3. Ï†ÑÏ≤¥ Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
                 val allCancelIntent = Intent("com.example.daegu_bus_app.ALL_TRACKING_CANCELLED")
                 context.sendBroadcast(allCancelIntent)
                 Log.d(TAG, "Sent ALL_TRACKING_CANCELLED broadcast")

                 // 4. Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ ÏßÅÏ†ë Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° ÏãúÎèÑ
                 try {
                     if (context is MainActivity) {
                         context._methodChannel?.invokeMethod("onAllAlarmsCanceled", null)
                         Log.d(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÎ°ú Î™®Îì† ÏïåÎûå Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ ÏßÅÏ†ë Ï†ÑÏÜ° ÏôÑÎ£å (NotificationHandler)")
                     }
                 } catch (e: Exception) {
                     Log.e(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑê Ï†ÑÏÜ° Ïò§Î•ò (NotificationHandler): ${e.message}")
                 }

                 // 5. ÏßÄÏó∞Îêú Ï∂îÍ∞Ä ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå (Î∞±ÏóÖ)
                 Handler(Looper.getMainLooper()).postDelayed({
                     try {
                         val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                         notificationManager.cancel(ONGOING_NOTIFICATION_ID)
                         notificationManager.cancelAll()
                         Log.d(TAG, "ÏßÄÏó∞Îêú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å")
                     } catch (e: Exception) {
                         Log.e(TAG, "ÏßÄÏó∞Îêú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                     }
                 }, 500)
             }
         } catch (e: Exception) {
             Log.e(TAG, "Error cancelling notification ID $id: ${e.message}", e)
         }
     }

     fun cancelOngoingTrackingNotification() {
         Log.d(TAG, "Canceling ongoing tracking notification ID: $ONGOING_NOTIFICATION_ID")
         try {
             // 1. Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå (ÏµúÏö∞ÏÑ†)
             try {
                 val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                 systemNotificationManager.cancel(ONGOING_NOTIFICATION_ID)
                 systemNotificationManager.cancelAll()
                 Log.d(TAG, "Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å (cancelOngoingTrackingNotification)")
             } catch (e: Exception) {
                 Log.e(TAG, "Ï¶âÏãú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
             }

             // 2. NotificationManagerCompatÏúºÎ°úÎèÑ Ï∑®ÏÜå
             try {
                 val notificationManager = NotificationManagerCompat.from(context)
                 notificationManager.cancel(ONGOING_NOTIFICATION_ID)
                 notificationManager.cancelAll()
                 Log.d(TAG, "NotificationManagerCompatÏúºÎ°ú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å")
             } catch (e: Exception) {
                 Log.e(TAG, "NotificationManagerCompat Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
             }

             // 3. BusAlertServiceÏóê Ï§ëÏßÄ ÏöîÏ≤≠
             val stopIntent = Intent(context, BusAlertService::class.java).apply {
                 action = BusAlertService.ACTION_STOP_TRACKING
                 flags = Intent.FLAG_ACTIVITY_NEW_TASK
             }
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 context.startForegroundService(stopIntent)
             } else {
                 context.startService(stopIntent)
             }
             Log.d(TAG, "Sent stop tracking request to BusAlertService")

             // 4. Ï†ÑÏ≤¥ Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ (Ï¶âÏãú)
             val allCancelIntent = Intent("com.example.daegu_bus_app.ALL_TRACKING_CANCELLED")
             context.sendBroadcast(allCancelIntent)
             Log.d(TAG, "Sent ALL_TRACKING_CANCELLED broadcast")

             // 5. Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ ÏßÅÏ†ë Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° ÏãúÎèÑ
             try {
                 if (context is MainActivity) {
                     context._methodChannel?.invokeMethod("onAllAlarmsCanceled", null)
                     Log.d(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÎ°ú Î™®Îì† ÏïåÎûå Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ ÏßÅÏ†ë Ï†ÑÏÜ° ÏôÑÎ£å (cancelOngoingTrackingNotification)")
                 }
             } catch (e: Exception) {
                 Log.e(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑê Ï†ÑÏÜ° Ïò§Î•ò (cancelOngoingTrackingNotification): ${e.message}")
             }

             // 6. ÏßÄÏó∞Îêú Ï∂îÍ∞Ä ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå (Î∞±ÏóÖ)
             Handler(Looper.getMainLooper()).postDelayed({
                 try {
                     val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                     systemNotificationManager.cancel(ONGOING_NOTIFICATION_ID)
                     systemNotificationManager.cancelAll()
                     Log.d(TAG, "ÏßÄÏó∞Îêú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å (cancelOngoingTrackingNotification)")
                 } catch (e: Exception) {
                     Log.e(TAG, "ÏßÄÏó∞Îêú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                 }

                 // ÏßÄÏó∞Îêú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ÎèÑ Ï†ÑÏÜ°
                 context.sendBroadcast(allCancelIntent)
                 Log.d(TAG, "Sent delayed ALL_TRACKING_CANCELLED broadcast")
             }, 500)
         } catch (e: Exception) {
             Log.e(TAG, "Error cancelling ongoing tracking notification: ${e.message}", e)
         }
     }

     fun cancelAllNotifications() {
         Log.d(TAG, "Request to cancel ALL notifications")
         try {
             // 1. Ï¶âÏãú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå (ÏµúÏö∞ÏÑ†) - Í∞úÎ≥Ñ IDÍπåÏßÄ Í∞ïÏ†ú Ï∑®ÏÜå
             try {
                 val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                 
                 // Í∞úÎ≥Ñ ÏïåÎ¶º IDÎì§ Í∞ïÏ†ú Ï∑®ÏÜå (Ïó¨Îü¨ Î≤à ÏãúÎèÑ)
                 for (attempt in 1..3) {
                     systemNotificationManager.cancel(ONGOING_NOTIFICATION_ID)
                     systemNotificationManager.cancel(ARRIVING_SOON_NOTIFICATION_ID)
                     
                     // ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îêú ÏïåÎ¶º IDÎì§ÎèÑ Ï∑®ÏÜå (Î≤îÏúÑ Í∏∞Î∞ò)
                     for (i in ALERT_NOTIFICATION_ID_BASE..(ALERT_NOTIFICATION_ID_BASE + 1000)) {
                         systemNotificationManager.cancel(i)
                     }
                     
                     // Ï†ÑÏ≤¥ Ï∑®ÏÜå
                     systemNotificationManager.cancelAll()
                     
                     if (attempt < 3) {
                         Thread.sleep(100) // ÏßßÏùÄ ÏßÄÏó∞ ÌõÑ Ïû¨ÏãúÎèÑ
                     }
                 }
                 
                 Log.d(TAG, "Ï¶âÏãú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å (cancelAllNotifications)")
             } catch (e: Exception) {
                 Log.e(TAG, "Ï¶âÏãú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
             }

             // 2. NotificationManagerCompatÏúºÎ°úÎèÑ Ï∑®ÏÜå (Ïù¥Ï§ë Î≥¥Ïû•)
             try {
                 val notificationManager = NotificationManagerCompat.from(context)
                 
                 // Í∞úÎ≥Ñ ID Ï∑®ÏÜå ÌõÑ Ï†ÑÏ≤¥ Ï∑®ÏÜå
                 notificationManager.cancel(ONGOING_NOTIFICATION_ID)
                 notificationManager.cancel(ARRIVING_SOON_NOTIFICATION_ID)
                 
                 // ÎèôÏ†Å ID Î≤îÏúÑ Ï∑®ÏÜå
                 for (i in ALERT_NOTIFICATION_ID_BASE..(ALERT_NOTIFICATION_ID_BASE + 1000)) {
                     notificationManager.cancel(i)
                 }
                 
                 notificationManager.cancelAll()
                 Log.d(TAG, "NotificationManagerCompatÏúºÎ°ú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å")
             } catch (e: Exception) {
                 Log.e(TAG, "NotificationManagerCompat Î™®Îì† Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
             }

             // 3. BusAlertServiceÏóê Ï§ëÏßÄ ÏöîÏ≤≠
             val stopIntent = Intent(context, BusAlertService::class.java).apply {
                 action = BusAlertService.ACTION_STOP_TRACKING
             }
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 context.startForegroundService(stopIntent)
             } else {
                 context.startService(stopIntent)
             }
             Log.d(TAG, "Sent stop tracking request to BusAlertService")

             // 4. Ï†ÑÏ≤¥ Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
             val allCancelIntent = Intent("com.example.daegu_bus_app.ALL_TRACKING_CANCELLED")
             context.sendBroadcast(allCancelIntent)
             Log.d(TAG, "Sent ALL_TRACKING_CANCELLED broadcast")

             // 5. Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÏùÑ ÌÜµÌï¥ ÏßÅÏ†ë Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ° ÏãúÎèÑ
             try {
                 if (context is MainActivity) {
                     context._methodChannel?.invokeMethod("onAllAlarmsCanceled", null)
                     Log.d(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑêÎ°ú Î™®Îì† ÏïåÎûå Ï∑®ÏÜå Ïù¥Î≤§Ìä∏ ÏßÅÏ†ë Ï†ÑÏÜ° ÏôÑÎ£å (cancelAllNotifications)")
                 }
             } catch (e: Exception) {
                 Log.e(TAG, "Flutter Î©îÏÑúÎìú Ï±ÑÎÑê Ï†ÑÏÜ° Ïò§Î•ò (cancelAllNotifications): ${e.message}")
             }

             // 6. ÏßÄÏó∞Îêú Ï∂îÍ∞Ä ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå (Î∞±ÏóÖ) - Îçî Í∞ïÎ†•ÌïòÍ≤å
             Handler(Looper.getMainLooper()).postDelayed({
                 try {
                     val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                     
                     // Í∞úÎ≥Ñ IDÎì§ Îã§Ïãú ÌïúÎ≤à Í∞ïÏ†ú Ï∑®ÏÜå
                     systemNotificationManager.cancel(ONGOING_NOTIFICATION_ID)
                     systemNotificationManager.cancel(ARRIVING_SOON_NOTIFICATION_ID)
                     
                     // Î≤îÏúÑ Í∏∞Î∞ò Ïû¨Ï∑®ÏÜå
                     for (i in ALERT_NOTIFICATION_ID_BASE..(ALERT_NOTIFICATION_ID_BASE + 1000)) {
                         systemNotificationManager.cancel(i)
                     }
                     
                     systemNotificationManager.cancelAll()
                     Log.d(TAG, "ÏßÄÏó∞Îêú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å (cancelAllNotifications)")
                 } catch (e: Exception) {
                     Log.e(TAG, "ÏßÄÏó∞Îêú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                 }
                 
                 // NotificationManagerCompatÎ°úÎèÑ Îã§Ïãú ÌïúÎ≤à Ï∑®ÏÜå
                 try {
                     val notificationManager = NotificationManagerCompat.from(context)
                     notificationManager.cancelAll()
                     Log.d(TAG, "ÏßÄÏó∞Îêú NotificationManagerCompat Ï∑®ÏÜå ÏôÑÎ£å")
                 } catch (e: Exception) {
                     Log.e(TAG, "ÏßÄÏó∞Îêú NotificationManagerCompat Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                 }
             }, 500)

             // 7. Ï∂îÍ∞Ä ÏßÄÏó∞ Ï∑®ÏÜå (2Ï¥à ÌõÑ ÏµúÏ¢Ö Ï†ïÎ¶¨)
             Handler(Looper.getMainLooper()).postDelayed({
                 try {
                     val systemNotificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                     systemNotificationManager.cancelAll()
                     Log.d(TAG, "ÏµúÏ¢Ö ÏßÄÏó∞Îêú Î™®Îì† ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå ÏôÑÎ£å")
                 } catch (e: Exception) {
                     Log.e(TAG, "ÏµúÏ¢Ö ÏßÄÏó∞Îêú ÎÖ∏Ìã∞ÌîºÏºÄÏù¥ÏÖò Ï∑®ÏÜå Ïò§Î•ò: ${e.message}")
                 }
             }, 2000)

         } catch (e: Exception) {
             Log.e(TAG, "Error cancelling all notifications: ${e.message}", e)
         }
     }

     // --- Regular Notification ---

     fun buildNotification(
         id: Int,
         busNo: String,
         stationName: String,
         remainingMinutes: Int,
         currentStation: String?,
         routeId: String?,
         isAutoAlarm: Boolean = false // ÏûêÎèôÏïåÎûå Ïó¨Î∂Ä Ï∂îÍ∞Ä
     ): Notification {
         val title = if (remainingMinutes <= 0) {
             "${busNo}Î≤à Î≤ÑÏä§ ÎèÑÏ∞©" // Îçî Í∞ÑÍ≤∞ÌïòÍ≤å
         } else {
             "${busNo}Î≤à Î≤ÑÏä§ ÏïåÎûå"
         }
         val contentText = if (remainingMinutes <= 0) {
             "${busNo}Î≤à Î≤ÑÏä§Í∞Ä ${stationName}Ïóê Í≥ß ÎèÑÏ∞©Ìï©ÎãàÎã§."
         } else {
             "${busNo}Î≤à Î≤ÑÏä§Í∞Ä ÏïΩ ${remainingMinutes}Î∂Ñ ÌõÑ ÎèÑÏ∞© ÏòàÏ†ïÏûÖÎãàÎã§."
         }
         val subText = if (currentStation != null && currentStation.isNotEmpty()) "ÌòÑÏû¨ ÏúÑÏπò: $currentStation" else null

         // Ïï± Ïã§Ìñâ Intent
         val openAppIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)?.apply {
             flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
         }
         val pendingIntent = if (openAppIntent != null) PendingIntent.getActivity(
             context, id, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
         ) else null

         // "Ï¢ÖÎ£å" Î≤ÑÌäº Intent (ÌäπÏ†ï ÏïåÎûå Ìï¥Ï†ú)
         val cancelIntent = Intent(context, BusAlertService::class.java).apply {
             action = BusAlertService.ACTION_STOP_SPECIFIC_ROUTE_TRACKING
             putExtra("routeId", routeId) // Ïù¥ ÏïåÎ¶ºÏùò routeId
             putExtra("notificationId", id)     // Ïù¥ ÏïåÎ¶ºÏùò ID
             putExtra("busNo", busNo)           // UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Ï∂îÍ∞Ä
             putExtra("stationName", stationName) // UI ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌï¥ Ï∂îÍ∞Ä
             if (isAutoAlarm) putExtra("isAutoAlarm", true) // ÏûêÎèôÏïåÎûåÏù¥Î©¥ ÌîåÎûòÍ∑∏ Ï∂îÍ∞Ä
         }
         val cancelPendingIntent = PendingIntent.getService(
             context, id + 1000, cancelIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE // requestCode Ï∂©Îèå Î∞©ÏßÄ
         )

         val builder = NotificationCompat.Builder(context, CHANNEL_ID_ALERT) // ÎèÑÏ∞© ÏïåÎ¶º Ï±ÑÎÑê ÏÇ¨Ïö©
             .setContentTitle(title)
             .setContentText(contentText)
             .setSmallIcon(R.mipmap.ic_launcher) // Ïï± ÏïÑÏù¥ÏΩò ÏÇ¨Ïö©
             .setPriority(NotificationCompat.PRIORITY_HIGH)
             .setCategory(NotificationCompat.CATEGORY_ALARM)
             .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
             .setColor(ContextCompat.getColor(context, R.color.alert_color))
             .setAutoCancel(true)
             .setDefaults(NotificationCompat.DEFAULT_ALL) // ÏÜåÎ¶¨, ÏßÑÎèô Îì± Í∏∞Î≥∏ ÏÑ§Ï†ï
             .addAction(R.drawable.ic_cancel, "Ï¢ÖÎ£å", cancelPendingIntent)

         if (subText != null) {
             builder.setSubText(subText)
         }
         if (pendingIntent != null) {
             builder.setContentIntent(pendingIntent)
         }

         Log.d(TAG, "‚úÖ Í∞úÎ≥Ñ ÏïåÎ¶º ÏÉùÏÑ±: ID=$id, Bus=$busNo, Station=$stationName, Route=$routeId")
         return builder.build()
     }

     // --- Arriving Soon Notification ---

     fun buildArrivingSoonNotification(
         busNo: String,
         stationName: String,
         currentStation: String?
     ): Notification {
         val title = "Bus Arriving Soon!"
         val contentText = "Bus $busNo is arriving soon at $stationName station."
         val subText = currentStation?.let { "Current location: $it" } ?: ""

         Log.d(TAG, "Building arriving soon notification: $contentText (ID: $ARRIVING_SOON_NOTIFICATION_ID)")

         val openAppIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)?.apply {
             flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
         }
         val pendingIntent = if (openAppIntent != null) PendingIntent.getActivity(
             context, ARRIVING_SOON_NOTIFICATION_ID, openAppIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
         ) else null

         val cancelIntent = Intent(context, BusAlertService::class.java).apply {
             action = ACTION_CANCEL_NOTIFICATION
             putExtra("notificationId", ARRIVING_SOON_NOTIFICATION_ID)
         }
         val cancelPendingIntent = PendingIntent.getService(
             context, ARRIVING_SOON_NOTIFICATION_ID + 1, cancelIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
         )

         val builder = NotificationCompat.Builder(context, CHANNEL_ID_ALERT)
             .setContentTitle(title)
             .setContentText(contentText)
             .setSubText(subText)
             .setSmallIcon(R.drawable.ic_bus_notification)
             .setPriority(NotificationCompat.PRIORITY_HIGH)
             .setCategory(NotificationCompat.CATEGORY_ALARM)
             .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
             .setColor(ContextCompat.getColor(context, R.color.alert_color))
             .setContentIntent(pendingIntent)
             .setAutoCancel(true)
             .addAction(R.drawable.ic_cancel, "Ï¢ÖÎ£å", cancelPendingIntent)
             .setDefaults(NotificationCompat.DEFAULT_ALL)

         return builder.build()
     }
}