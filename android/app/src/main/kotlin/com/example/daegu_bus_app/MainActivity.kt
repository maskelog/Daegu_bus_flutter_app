package com.example.daegu_bus_app

import android.os.Bundle
import android.content.pm.PackageManager
import android.Manifest
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.core.app.ActivityCompat
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import android.content.Intent
import org.json.JSONArray
import org.json.JSONObject
import android.media.AudioManager
import android.speech.tts.TextToSpeech
import java.util.Locale
import android.content.Context
import android.media.AudioDeviceInfo
import android.speech.tts.UtteranceProgressListener
import java.util.concurrent.ConcurrentHashMap
import android.app.NotificationManager
import android.widget.Toast
import androidx.annotation.NonNull
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import android.view.View
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Button
import android.widget.ImageButton
import android.os.Build
import android.app.NotificationChannel
import android.graphics.Color
import android.media.AudioAttributes
import android.net.Uri
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat

class MainActivity : FlutterActivity(), TextToSpeech.OnInitListener {
    private val BUS_API_CHANNEL = "com.example.daegu_bus_app/bus_api"
    private val NOTIFICATION_CHANNEL = "com.example.daegu_bus_app/notification"
    private val TTS_CHANNEL = "com.example.daegu_bus_app/tts"
    private val TAG = "MainActivity"
    private val ONGOING_NOTIFICATION_ID = 10000
    private lateinit var busApiService: BusApiService
    private var busAlertService: BusAlertService? = null
    private val NOTIFICATION_PERMISSION_REQUEST_CODE = 123
    private lateinit var audioManager: AudioManager
    private lateinit var tts: TextToSpeech
    private var _methodChannel: MethodChannel? = null
    private var bottomSheetDialog: BottomSheetDialog? = null
    private var bottomSheetBehavior: BottomSheetBehavior<View>? = null

    // TTS Ï§ëÎ≥µ Î∞©ÏßÄÎ•º ÏúÑÌïú Ìä∏ÎûòÌÇπ Îßµ
    private val ttsTracker = ConcurrentHashMap<String, Long>()
    private val TTS_DUPLICATE_THRESHOLD_MS = 300 // 0.3Ï¥à Ïù¥ÎÇ¥ Ï§ëÎ≥µ Î∞úÌôî Î∞©ÏßÄ

    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        _methodChannel = MethodChannel(flutterEngine.dartExecutor.binaryMessenger, BUS_API_CHANNEL)
        Log.d("MainActivity", "üîå Î©îÏÑúÎìú Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        setupMethodChannels(flutterEngine)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        try {
            super.onCreate(savedInstanceState)
            Log.d("MainActivity", " MainActivity ÏÉùÏÑ±")

            // ÏäπÏ∞® ÏôÑÎ£å Ïï°ÏÖò Ï≤òÎ¶¨
            if (intent?.action == "com.example.daegu_bus_app.BOARDING_COMPLETE") {
                handleBoardingComplete()
            }

            busApiService = BusApiService(this)
            audioManager = getSystemService(AUDIO_SERVICE) as AudioManager
            
            // TTS Ï¥àÍ∏∞Ìôî
            try {
                tts = TextToSpeech(this, this)
            } catch (e: Exception) {
                Log.e(TAG, "TTS Ï¥àÍ∏∞Ìôî Ïò§Î•ò: ${e.message}", e)
            }

            try {
                val serviceIntent = Intent(this, BusAlertService::class.java)
                startService(serviceIntent)
                busAlertService = BusAlertService.getInstance(this)
            } catch (e: Exception) {
                Log.e(TAG, "BusAlertService Ï¥àÍ∏∞Ìôî Ïã§Ìå®: ${e.message}", e)
            }

            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
                if (ContextCompat.checkSelfPermission(
                        this,
                        Manifest.permission.POST_NOTIFICATIONS
                    ) != PackageManager.PERMISSION_GRANTED
                ) {
                    ActivityCompat.requestPermissions(
                        this,
                        arrayOf(Manifest.permission.POST_NOTIFICATIONS),
                        NOTIFICATION_PERMISSION_REQUEST_CODE
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "MainActivity onCreate Ïò§Î•ò: ${e.message}", e)
        }
    }

    override fun onInit(status: Int) {
        try {
            if (status == TextToSpeech.SUCCESS) {
                try {
                    val result = tts.setLanguage(Locale.KOREAN)
                    if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                        Log.e(TAG, "Korean language is not supported")
                    }
                    
                    // Î∞úÌôî ÏÜçÎèÑÏôÄ ÌîºÏπò ÏµúÏ†ÅÌôî
                    tts.setSpeechRate(1.2f)  // 0.9fÏóêÏÑú 1.2fÎ°ú Ï¶ùÍ∞Ä
                    tts.setPitch(1.1f)       // ÌîºÏπò Ï∂îÍ∞Ä
                    
                    // TTS Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
                    tts.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                        override fun onStart(utteranceId: String?) {
                            Log.d(TAG, "TTS Î∞úÌôî ÏãúÏûë: $utteranceId")
                        }

                        override fun onDone(utteranceId: String?) {
                            Log.d(TAG, "TTS Î∞úÌôî ÏôÑÎ£å: $utteranceId")
                        }

                        override fun onError(utteranceId: String?) {
                            Log.e(TAG, "TTS Î∞úÌôî Ïò§Î•ò: $utteranceId")
                        }
                    })
                    Log.d(TAG, "TTS Ï¥àÍ∏∞Ìôî ÏÑ±Í≥µ")
                } catch (e: Exception) {
                    Log.e(TAG, "TTS ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
                }
            } else {
                Log.e(TAG, "TTS Ï¥àÍ∏∞Ìôî Ïã§Ìå®: $status")
            }
        } catch (e: Exception) {
            Log.e(TAG, "TTS onInit Ïò§Î•ò: ${e.message}", e)
        }
    }

    private fun setupMethodChannels(flutterEngine: FlutterEngine) {
        try {
            MethodChannel(flutterEngine.dartExecutor.binaryMessenger, BUS_API_CHANNEL).setMethodCallHandler { call, result ->
                when (call.method) {
                    "searchStations" -> {
                        val searchText = call.argument<String>("searchText") ?: ""
                        if (searchText.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "Í≤ÄÏÉâÏñ¥Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        val searchType = call.argument<String>("searchType") ?: "web"
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                if (searchType == "local") {
                                    val databaseHelper = DatabaseHelper.getInstance(this@MainActivity)
                                    val stations = databaseHelper.searchStations(searchText)
                                    Log.d(TAG, "Î°úÏª¨ Ï†ïÎ•òÏû• Í≤ÄÏÉâ Í≤∞Í≥º: ${stations.size}Í∞ú")
                                    val jsonArray = JSONArray()
                                    stations.forEach { station ->
                                        val jsonObj = JSONObject().apply {
                                            put("id", station.bsId)
                                            put("name", station.bsNm)
                                            put("isFavorite", false)
                                            put("wincId", station.bsId)
                                            put("ngisXPos", station.longitude)
                                            put("ngisYPos", station.latitude)
                                            put("routeList", JSONArray())
                                        }
                                        jsonArray.put(jsonObj)
                                    }
                                    result.success(jsonArray.toString())
                                } else {
                                    val stations = busApiService.searchStations(searchText)
                                    Log.d(TAG, "Ïõπ Ï†ïÎ•òÏû• Í≤ÄÏÉâ Í≤∞Í≥º: ${stations.size}Í∞ú")
                                    val jsonArray = JSONArray()
                                    stations.forEach { station ->
                                        Log.d(TAG, "Station - ID: ${station.bsId}, Name: ${station.bsNm}")
                                        val jsonObj = JSONObject().apply {
                                            put("id", station.bsId)
                                            put("name", station.bsNm)
                                            put("isFavorite", false)
                                            put("wincId", station.bsId)
                                            put("ngisXPos", 0.0)
                                            put("ngisYPos", 0.0)
                                            put("routeList", JSONArray())
                                        }
                                        jsonArray.put(jsonObj)
                                    }
                                    result.success(jsonArray.toString())
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Ï†ïÎ•òÏû• Í≤ÄÏÉâ Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "Ï†ïÎ•òÏû• Í≤ÄÏÉâ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "startTtsTracking" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        val stationId = call.argument<String>("stationId") ?: ""
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        
                        // Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ - Îπà Ïù∏ÏûêÎ•º ÎåÄÏ≤¥ Í∞íÏúºÎ°ú Ï±ÑÏö∞Í∏∞
                        val effectiveRouteId = routeId.takeIf { it.isNotEmpty() } ?: busNo
                        val effectiveStationId = stationId.takeIf { it.isNotEmpty() } ?: effectiveRouteId
                        val effectiveBusNo = busNo.takeIf { it.isNotEmpty() } ?: effectiveRouteId
                        
                        if (effectiveRouteId.isEmpty() || effectiveStationId.isEmpty() || 
                            effectiveBusNo.isEmpty() || stationName.isEmpty()) {
                            Log.e(TAG, "ÌïÑÏàò Ïù∏Ïûê Ïò§Î•ò - routeId:$routeId, stationId:$stationId, busNo:$busNo, stationName:$stationName")
                            result.error("INVALID_ARGUMENT", "ÌïÑÏàò Ïù∏Ïûê ÎàÑÎùΩ", null)
                            return@setMethodCallHandler
                        }
                        
                        try {
                            Log.d(TAG, "TTS Ï∂îÏ†Å ÏãúÏûë ÏöîÏ≤≠: $effectiveBusNo, $stationName")
                            busAlertService?.startTtsTracking(effectiveRouteId, effectiveStationId, effectiveBusNo, stationName)
                            result.success("TTS Ï∂îÏ†Å ÏãúÏûëÎê®")
                        } catch (e: Exception) {
                            Log.e(TAG, "TTS Ï∂îÏ†Å ÏãúÏûë Ïò§Î•ò: ${e.message}", e)
                            result.error("TTS_ERROR", "TTS Ï∂îÏ†Å ÏãúÏûë Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "updateBusTrackingNotification" -> {
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        // Ensure remainingMinutes is an Integer
                        val remainingMinutes = call.argument<Int>("remainingMinutes") ?: 0
                        val currentStation = call.argument<String>("currentStation") ?: ""
                        try {
                            Log.d(TAG, "FlutterÏóêÏÑú Î≤ÑÏä§ Ï∂îÏ†Å ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏ≤≠: $busNo, ÎÇ®ÏùÄ ÏãúÍ∞Ñ: $remainingMinutes Î∂Ñ")
                            busAlertService?.showNotification(
                                id = ONGOING_NOTIFICATION_ID,
                                busNo = busNo,
                                stationName = stationName,
                                remainingMinutes = remainingMinutes,
                                currentStation = currentStation,
                                isOngoing = true
                            )
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "Î≤ÑÏä§ Ï∂îÏ†Å ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: ${e.message}", e)
                            result.error("NOTIFICATION_ERROR", "Î≤ÑÏä§ Ï∂îÏ†Å ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    "registerBusArrivalReceiver" -> {
                        try {
                            busAlertService?.registerBusArrivalReceiver()
                            result.success("Îì±Î°ù ÏôÑÎ£å")
                        } catch (e: Exception) {
                            Log.e(TAG, "BusArrivalReceiver Îì±Î°ù Ïò§Î•ò: ${e.message}", e)
                            result.error("REGISTER_ERROR", "Î≤ÑÏä§ ÎèÑÏ∞© Î¶¨ÏãúÎ≤Ñ Îì±Î°ù Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "startBusMonitoring" -> {
                        val routeId = call.argument<String>("routeId")
                        val stationId = call.argument<String>("stationId")
                        val stationName = call.argument<String>("stationName")
                        try {
                            busAlertService?.addMonitoredRoute(routeId!!, stationId!!, stationName!!)
                            result.success("Ï∂îÏ†Å ÏãúÏûëÎê®")
                        } catch (e: Exception) {
                            Log.e(TAG, "Î≤ÑÏä§ Ï∂îÏ†Å ÏãúÏûë Ïò§Î•ò: ${e.message}", e)
                            result.error("MONITOR_ERROR", "Î≤ÑÏä§ Ï∂îÏ†Å Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "findNearbyStations" -> {
                        val latitude = call.argument<Double>("latitude") ?: 0.0
                        val longitude = call.argument<Double>("longitude") ?: 0.0
                        val radiusMeters = call.argument<Double>("radiusMeters") ?: 500.0
                        if (latitude == 0.0 || longitude == 0.0) {
                            result.error("INVALID_ARGUMENT", "ÏúÑÎèÑ ÎòêÎäî Í≤ΩÎèÑÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                Log.d(TAG, "Ï£ºÎ≥Ä Ï†ïÎ•òÏû• Í≤ÄÏÉâ ÏöîÏ≤≠: lat=$latitude, lon=$longitude, radius=${radiusMeters}m")
                                val databaseHelper = DatabaseHelper.getInstance(this@MainActivity)
                                val nearbyStations = databaseHelper.searchStations(
                                    searchText = "",
                                    latitude = latitude,
                                    longitude = longitude,
                                    radiusInMeters = radiusMeters
                                )
                                Log.d(TAG, "Ï£ºÎ≥Ä Ï†ïÎ•òÏû• Í≤ÄÏÉâ Í≤∞Í≥º: ${nearbyStations.size}Í∞ú (Í≤ÄÏÉâ Î∞òÍ≤Ω: ${radiusMeters}m)")
                                val jsonArray = JSONArray()
                                nearbyStations.forEach { station ->
                                    val jsonObj = JSONObject().apply {
                                        put("id", station.stationId ?: station.bsId)
                                        put("name", station.bsNm)
                                        put("isFavorite", false)
                                        put("wincId", station.bsId)
                                        put("distance", station.distance)
                                        put("ngisXPos", station.longitude)
                                        put("ngisYPos", station.latitude)
                                        put("routeList", "[]")
                                    }
                                    jsonArray.put(jsonObj)
                                    Log.d(TAG, "Ï†ïÎ•òÏû• Ï†ïÎ≥¥ - Ïù¥Î¶Ñ: ${station.bsNm}, ID: ${station.bsId}, ÏúÑÏπò: (${station.longitude}, ${station.latitude}), Í±∞Î¶¨: ${station.distance}m")
                                }
                                result.success(jsonArray.toString())
                            } catch (e: Exception) {
                                Log.e(TAG, "Ï£ºÎ≥Ä Ï†ïÎ•òÏû• Í≤ÄÏÉâ Ïò§Î•ò: ${e.message}", e)
                                result.error("DB_ERROR", "Ï£ºÎ≥Ä Ï†ïÎ•òÏû• Í≤ÄÏÉâ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getBusRouteDetails" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        if (routeId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "ÎÖ∏ÏÑ† IDÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val searchRoutes = busApiService.searchBusRoutes(routeId)
                                val routeInfo = busApiService.getBusRouteInfo(routeId)
                                val mergedRoute = routeInfo ?: searchRoutes.firstOrNull()
                                result.success(busApiService.convertToJson(mergedRoute ?: "{}"))
                            } catch (e: Exception) {
                                Log.e(TAG, "Î≤ÑÏä§ ÎÖ∏ÏÑ† ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "Î≤ÑÏä§ ÎÖ∏ÏÑ† ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "searchBusRoutes" -> {
                        val searchText = call.argument<String>("searchText") ?: ""
                        if (searchText.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "Í≤ÄÏÉâÏñ¥Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val routes = busApiService.searchBusRoutes(searchText)
                                Log.d(TAG, "ÎÖ∏ÏÑ† Í≤ÄÏÉâ Í≤∞Í≥º: ${routes.size}Í∞ú")
                                if (routes.isEmpty()) Log.d(TAG, "Í≤ÄÏÉâ Í≤∞Í≥º ÏóÜÏùå: $searchText")
                                val jsonArray = JSONArray()
                                routes.forEach { route ->
                                    val jsonObj = JSONObject().apply {
                                        put("id", route.id)
                                        put("routeNo", route.routeNo)
                                        put("routeTp", route.routeTp)
                                        put("startPoint", route.startPoint)
                                        put("endPoint", route.endPoint)
                                        put("routeDescription", route.routeDescription)
                                    }
                                    jsonArray.put(jsonObj)
                                }
                                result.success(jsonArray.toString())
                            } catch (e: Exception) {
                                Log.e(TAG, "ÎÖ∏ÏÑ† Í≤ÄÏÉâ Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "ÎÖ∏ÏÑ† Í≤ÄÏÉâ Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getStationIdFromBsId" -> {
                        val bsId = call.argument<String>("bsId") ?: ""
                        if (bsId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "bsIdÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        if (bsId.startsWith("7") && bsId.length == 10) {
                            Log.d(TAG, "bsId '$bsId'Îäî Ïù¥ÎØ∏ stationId ÌòïÏãùÏûÖÎãàÎã§")
                            result.success(bsId)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val stationId = busApiService.getStationIdFromBsId(bsId)
                                if (stationId != null && stationId.isNotEmpty()) {
                                    Log.d(TAG, "bsId '${bsId}'Ïóê ÎåÄÌïú stationId '$stationId' Ï°∞Ìöå ÏÑ±Í≥µ")
                                    result.success(stationId)
                                } else {
                                    Log.e(TAG, "stationId Ï°∞Ìöå Ïã§Ìå®: $bsId")
                                    result.error("NOT_FOUND", "stationIdÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $bsId", null)
                                }
                            } catch (e: Exception) {
                                Log.e(TAG, "Ï†ïÎ•òÏû• ID Î≥ÄÌôò Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "stationId Î≥ÄÌôò Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getStationInfo" -> {
                        val stationId = call.argument<String>("stationId") ?: ""
                        if (stationId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "Ï†ïÎ•òÏû• IDÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val stationInfoJson = busApiService.getStationInfo(stationId)
                                Log.d(TAG, "Ï†ïÎ•òÏû• Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å: $stationId")
                                result.success(stationInfoJson)
                            } catch (e: Exception) {
                                Log.e(TAG, "Ï†ïÎ•òÏû• Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "Ï†ïÎ•òÏû• Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getBusArrivalByRouteId" -> {
                        val stationId = call.argument<String>("stationId") ?: ""
                        val routeId = call.argument<String>("routeId") ?: ""
                        if (stationId.isEmpty() || routeId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "Ï†ïÎ•òÏû• ID ÎòêÎäî ÎÖ∏ÏÑ† IDÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val arrivalInfo = busApiService.getBusArrivalInfoByRouteId(stationId, routeId)
                                result.success(busApiService.convertToJson(arrivalInfo ?: "{}"))
                            } catch (e: Exception) {
                                Log.e(TAG, "ÎÖ∏ÏÑ†Î≥Ñ Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "ÎÖ∏ÏÑ†Î≥Ñ Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getBusRouteInfo" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        if (routeId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "ÎÖ∏ÏÑ† IDÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val routeInfo = busApiService.getBusRouteInfo(routeId)
                                result.success(busApiService.convertToJson(routeInfo ?: "{}"))
                            } catch (e: Exception) {
                                Log.e(TAG, "Î≤ÑÏä§ ÎÖ∏ÏÑ† Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "Î≤ÑÏä§ ÎÖ∏ÏÑ† Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getBusPositionInfo" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        if (routeId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "ÎÖ∏ÏÑ† IDÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val positionInfo = busApiService.getBusPositionInfo(routeId)
                                result.success(positionInfo)
                            } catch (e: Exception) {
                                Log.e(TAG, "Ïã§ÏãúÍ∞Ñ Î≤ÑÏä§ ÏúÑÏπò Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "Ïã§ÏãúÍ∞Ñ Î≤ÑÏä§ ÏúÑÏπò Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    "getRouteStations" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        if (routeId.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "routeIdÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        CoroutineScope(Dispatchers.Main).launch {
                            try {
                                val stations = busApiService.getBusRouteMap(routeId)
                                Log.d(TAG, "ÎÖ∏ÏÑ†ÎèÑ Ï°∞Ìöå Í≤∞Í≥º: ${stations.size}Í∞ú Ï†ïÎ•òÏû•")
                                result.success(busApiService.convertRouteStationsToJson(stations))
                            } catch (e: Exception) {
                                Log.e(TAG, "ÎÖ∏ÏÑ†ÎèÑ Ï°∞Ìöå Ïò§Î•ò: ${e.message}", e)
                                result.error("API_ERROR", "ÎÖ∏ÏÑ†ÎèÑ Ï°∞Ìöå Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                            }
                        }
                    }
                    else -> result.notImplemented()
                }
            }

            MethodChannel(flutterEngine.dartExecutor.binaryMessenger, NOTIFICATION_CHANNEL).setMethodCallHandler { call, result ->
                if (busAlertService == null) {
                    result.error("SERVICE_UNAVAILABLE", "ÏïåÎ¶º ÏÑúÎπÑÏä§Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§", null)
                    return@setMethodCallHandler
                }
                when (call.method) {
                    "initialize" -> {
                        try {
                            busAlertService?.initialize(this, flutterEngine)
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÏïåÎ¶º ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî Ïò§Î•ò: ${e.message}", e)
                            result.error("INIT_ERROR", "ÏïåÎ¶º ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    "showNotification" -> {
                        val id = call.argument<Int>("id") ?: 0
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        val remainingMinutes = call.argument<Int>("remainingMinutes") ?: 0
                        val currentStation = call.argument<String>("currentStation")
                        val payload = call.argument<String>("payload")
                        try {
                            busAlertService?.showNotification(id, busNo, stationName, remainingMinutes, currentStation, payload)
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÏïåÎ¶º ÌëúÏãú Ïò§Î•ò: ${e.message}", e)
                            result.error("NOTIFICATION_ERROR", "ÏïåÎ¶º ÌëúÏãú Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    "showOngoingBusTracking" -> {
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        val remainingMinutes = call.argument<Int>("remainingMinutes") ?: 0
                        val currentStation = call.argument<String>("currentStation")
                        val isUpdate = call.argument<Boolean>("isUpdate") ?: false
                        try {
                            busAlertService?.showNotification(
                                id = ONGOING_NOTIFICATION_ID,
                                busNo = busNo,
                                stationName = stationName,
                                remainingMinutes = remainingMinutes,
                                currentStation = currentStation,
                                payload = "bus_tracking_$busNo",
                                isOngoing = true
                            )
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÏßÄÏÜç ÏïåÎ¶º ÌëúÏãú Ïò§Î•ò: ${e.message}", e)
                            result.error("NOTIFICATION_ERROR", "ÏßÄÏÜç ÏïåÎ¶º ÌëúÏãú Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    "showBusArrivingSoon" -> {
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        val currentStation = call.argument<String>("currentStation")
                        try {
                            busAlertService?.showBusArrivingSoon(busNo, stationName, currentStation)
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÎèÑÏ∞© ÏûÑÎ∞ï ÏïåÎ¶º ÌëúÏãú Ïò§Î•ò: ${e.message}", e)
                            result.error("NOTIFICATION_ERROR", "ÎèÑÏ∞© ÏûÑÎ∞ï ÏïåÎ¶º ÌëúÏãú Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    "cancelNotification" -> {
                        val id = call.argument<Int>("id") ?: 0
                        busAlertService?.cancelNotification(id)
                        result.success(true)
                    }
                    "cancelOngoingTracking" -> {
                        busAlertService?.cancelOngoingTracking()
                        result.success(true)
                    }
                    "cancelAllNotifications" -> {
                        busAlertService?.cancelAllNotifications()
                        result.success(true)
                    }
                    "setAlarmSound" -> {
                        try {
                            val filename = call.argument<String>("filename") ?: ""
                            val useTts = call.argument<Boolean>("useTts") ?: false
                            Log.d(TAG, "ÏïåÎûåÏùå ÏÑ§Ï†ï ÏöîÏ≤≠: $filename, TTS ÏÇ¨Ïö©: $useTts")
                            busAlertService?.setAlarmSound(filename, useTts)
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÏïåÎûåÏùå ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
                            result.error("ALARM_SOUND_ERROR", "ÏïåÎûåÏùå ÏÑ§Ï†ï Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", null)
                        }
                    }
                    else -> result.notImplemented()
                }
            }

            MethodChannel(flutterEngine.dartExecutor.binaryMessenger, TTS_CHANNEL).setMethodCallHandler { call, result ->
                when (call.method) {
                    "forceEarphoneOutput" -> {
                        try {
                            // ÎØ∏ÎîîÏñ¥ Ï∂úÎ†•ÏúºÎ°ú Í≥†Ï†ï
                            audioManager.mode = AudioManager.MODE_NORMAL
                            audioManager.setStreamVolume(
                                AudioManager.STREAM_MUSIC,
                                audioManager.getStreamVolume(AudioManager.STREAM_MUSIC),
                                0
                            )
                            Log.d(TAG, "ÎØ∏ÎîîÏñ¥ Ï∂úÎ†• Í≥†Ï†ï ÏôÑÎ£å")
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "Ïò§ÎîîÏò§ Ï∂úÎ†• ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
                            result.error("AUDIO_ERROR", "Ïò§ÎîîÏò§ Ï∂úÎ†• ÏÑ§Ï†ï Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "speakTTS" -> {
                        val message = call.argument<String>("message") ?: ""
                        val isHeadphoneMode = call.argument<Boolean>("isHeadphoneMode") ?: false

                        // Ï§ëÎ≥µ Î∞úÌôî Î∞©ÏßÄ Î°úÏßÅ Ï∂îÍ∞Ä
                        val currentTime = System.currentTimeMillis()
                        val lastSpeakTime = ttsTracker[message] ?: 0

                        if (currentTime - lastSpeakTime > TTS_DUPLICATE_THRESHOLD_MS) {
                            // Ï§ëÎ≥µ ÏïÑÎãàÎ©¥ Î∞úÌôî ÏßÑÌñâ
                            speakTTS(message, isHeadphoneMode)

                            // Î∞úÌôî ÏãúÍ∞Ñ Í∏∞Î°ù
                            ttsTracker[message] = currentTime

                            result.success(true)
                        } else {
                            // Ï§ëÎ≥µ Î∞úÌôî Î∞©ÏßÄ
                            Log.d(TAG, "Ï§ëÎ≥µ TTS Î∞úÌôî Î∞©ÏßÄ: $message")
                            result.success(false)
                        }
                    }
                    "setAudioOutputMode" -> {
                        val mode = call.argument<Int>("mode") ?: 2  // Í∏∞Î≥∏Í∞í: ÏûêÎèô Í∞êÏßÄ
                        try {
                            busAlertService?.setAudioOutputMode(mode)
                            Log.d(TAG, "Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÑ§Ï†ï: $mode")
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
                            result.error("AUDIO_MODE_ERROR", "Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÑ§Ï†ï Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "speakEarphoneOnly" -> {
                        val message = call.argument<String>("message") ?: ""
                        if (message.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "Î©îÏãúÏßÄÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", null)
                            return@setMethodCallHandler
                        }
                        try {
                            // ÎØ∏ÎîîÏñ¥ Ï∂úÎ†•ÏúºÎ°ú Í≥†Ï†ï
                            audioManager.mode = AudioManager.MODE_NORMAL
                            
                            // Í∞êÏãú Í∞ÄÎä•Ìïú Î∞úÌôî ID ÏÉùÏÑ±
                            val utteranceId = "EARPHONE_${System.currentTimeMillis()}"
                            val params = Bundle().apply {
                                putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
                                putInt(TextToSpeech.Engine.KEY_PARAM_STREAM, AudioManager.STREAM_MUSIC)
                            }
                            
                            // UI Ïä§Î†àÎìúÏóêÏÑú Ïã§Ìñâ
                            runOnUiThread {
                                try {
                                    val ttsResult = tts.speak(message, TextToSpeech.QUEUE_FLUSH, params, utteranceId)
                                    Log.d(TAG, "TTS Ïù¥Ïñ¥Ìè∞ Î∞úÌôî ÏãúÏûë: $message, Í≤∞Í≥º: $ttsResult")
                                } catch (e: Exception) {
                                    Log.e(TAG, "TTS Ïù¥Ïñ¥Ìè∞ Î∞úÌôî Ïò§Î•ò: ${e.message}", e)
                                }
                            }
                            
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "Ïù¥Ïñ¥Ìè∞ TTS Ïã§Ìñâ Ïò§Î•ò: ${e.message}", e)
                            result.error("TTS_ERROR", "Ïù¥Ïñ¥Ìè∞ TTS Î∞úÌôî Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "startTtsTracking" -> {
                        val routeId = call.argument<String>("routeId") ?: ""
                        val stationId = call.argument<String>("stationId") ?: ""
                        val busNo = call.argument<String>("busNo") ?: ""
                        val stationName = call.argument<String>("stationName") ?: ""
                        if (routeId.isEmpty() || stationId.isEmpty() || busNo.isEmpty() || stationName.isEmpty()) {
                            result.error("INVALID_ARGUMENT", "ÌïÑÏàò Ïù∏Ïûê ÎàÑÎùΩ", null)
                            return@setMethodCallHandler
                        }
                        try {
                            busAlertService?.startTtsTracking(routeId, stationId, busNo, stationName)
                            result.success("TTS Ï∂îÏ†Å ÏãúÏûëÎê®")
                        } catch (e: Exception) {
                            Log.e(TAG, "TTS Ï∂îÏ†Å ÏãúÏûë Ïò§Î•ò: ${e.message}", e)
                            result.error("TTS_ERROR", "TTS Ï∂îÏ†Å ÏãúÏûë Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "stopTtsTracking" -> {
                        try {
                            busAlertService?.stopTtsTracking(forceStop = true) // forceStop = trueÎ°ú ÏÑ§Ï†ï
                            tts.stop()
                            Log.d(TAG, "TTS Ï∂îÏ†Å Ï§ëÏßÄ")
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "TTS Ï∂îÏ†Å Ï§ëÏßÄ Ïò§Î•ò: ${e.message}", e)
                            result.error("TTS_ERROR", "TTS Ï∂îÏ†Å Ï§ëÏßÄ Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    "stopTTS" -> {
                        try {
                            tts.stop()
                            Log.d(TAG, "ÎÑ§Ïù¥Ìã∞Î∏å TTS Ï†ïÏßÄ")
                            result.success(true)
                        } catch (e: Exception) {
                            Log.e(TAG, "ÎÑ§Ïù¥Ìã∞Î∏å TTS Ï†ïÏßÄ Ïò§Î•ò: ${e.message}", e)
                            result.error("TTS_ERROR", "TTS Ï†ïÏßÄ Ïã§Ìå®: ${e.message}", null)
                        }
                    }
                    else -> result.notImplemented()
                }
            }

            // Ï¥àÍ∏∞Ìôî ÏãúÎèÑ
            try {
                busAlertService?.initialize(this, flutterEngine)
            } catch (e: Exception) {
                Log.e(TAG, "ÏïåÎ¶º ÏÑúÎπÑÏä§ Ï¥àÍ∏∞Ìôî Ïò§Î•ò: ${e.message}", e)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Method Ï±ÑÎÑê ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
        }
    }

    private fun speakTTS(text: String, isHeadphoneMode: Boolean) {
        try {
            // Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú Ï†ïÎ≥¥ Î°úÍπÖ (Ï∂îÍ∞Ä)
            val audioManager = getSystemService(AUDIO_SERVICE) as AudioManager
            val isWiredHeadsetConnected = audioManager.isWiredHeadsetOn
            val isBluetoothConnected = audioManager.isBluetoothA2dpOn
            Log.d(TAG, "üéßüîä TTS Ïò§ÎîîÏò§ ÏÉÅÌÉú ÌôïÏù∏ ==========================================")
            Log.d(TAG, "üéß Ïù¥Ïñ¥Ìè∞ Ïó∞Í≤∞ ÏÉÅÌÉú: Ïú†ÏÑ†=${isWiredHeadsetConnected}, Î∏îÎ£®Ìà¨Ïä§=${isBluetoothConnected}")
            Log.d(TAG, "üéß ÏöîÏ≤≠Îêú Î™®Îìú: ${if (isHeadphoneMode) "Ïù¥Ïñ¥Ìè∞ Ï†ÑÏö©" else "ÏùºÎ∞ò Î™®Îìú"}")
            if (busAlertService != null) {
                val mode = busAlertService?.getAudioOutputMode() ?: -1
                val modeName = when(mode) {
                    0 -> "Ïù¥Ïñ¥Ìè∞ Ï†ÑÏö©"
                    1 -> "Ïä§ÌîºÏª§ Ï†ÑÏö©"
                    2 -> "ÏûêÎèô Í∞êÏßÄ"
                    else -> "Ïïå Ïàò ÏóÜÏùå"
                }
                Log.d(TAG, "üéß ÌòÑÏû¨ ÏÑ§Ï†ïÎêú Ïò§ÎîîÏò§ Î™®Îìú: $modeName ($mode)")
            } else {
                Log.d(TAG, "üéß busAlertServiceÍ∞Ä nullÏù¥Ïñ¥ÏÑú Ïò§ÎîîÏò§ Î™®ÎìúÎ•º ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§")
            }
            Log.d(TAG, "üéß Î∞úÌôî ÌÖçÏä§Ìä∏: \"$text\"")
            
            // Í∞ÑÏÜåÌôîÎêú ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï
            val utteranceId = "TTS_${System.currentTimeMillis()}"
            val params = Bundle().apply {
                putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
                // ÏïåÎ¶º Ïä§Ìä∏Î¶ºÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏó¨ Ïö∞ÏÑ†ÏàúÏúÑ ÎÜíÏûÑ
                putInt(TextToSpeech.Engine.KEY_PARAM_STREAM, AudioManager.STREAM_NOTIFICATION)
                putFloat(TextToSpeech.Engine.KEY_PARAM_VOLUME, 1.0f)
            }
            
            // UI Ïä§Î†àÎìúÏóêÏÑú ÏßÅÏ†ë Ïã§Ìñâ
            runOnUiThread {
                try {
                    // Ìï≠ÏÉÅ QUEUE_FLUSH Î™®ÎìúÎ°ú Ïã§ÌñâÌïòÏó¨ ÏßÄÏó∞ ÏóÜÏù¥ Ï¶âÏãú Î∞úÌôî
                    val result = tts.speak(text, TextToSpeech.QUEUE_FLUSH, params, utteranceId)
                    Log.d(TAG, "üîä TTS Î∞úÌôî Í≤∞Í≥º: $result (0=ÏÑ±Í≥µ)")
                    Log.d(TAG, "üéßüîä TTS Î∞úÌôî ÏöîÏ≤≠ ÏôÑÎ£å ==========================================")
                } catch (e: Exception) {
                    Log.e(TAG, "TTS Î∞úÌôî Ïò§Î•ò: ${e.message}", e)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "speakTTS Ìò∏Ï∂ú Ïò§Î•ò: ${e.message}", e)
        }
    }

    override fun onDestroy() {
        try {
            // TTS Ï¢ÖÎ£å
            if (::tts.isInitialized) {
                try {
                    tts.stop()
                    tts.shutdown()
                    Log.d(TAG, "TTS ÏûêÏõê Ìï¥Ï†ú")
                } catch (e: Exception) {
                    Log.e(TAG, "TTS ÏûêÏõê Ìï¥Ï†ú Ïò§Î•ò: ${e.message}", e)
                }
            }
            super.onDestroy()
        } catch (e: Exception) {
            Log.e(TAG, "onDestroy Ïò§Î•ò: ${e.message}", e)
            super.onDestroy()
        }
    }

    private fun calculateDistance(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
        val earthRadius = 6371000.0
        val dLat = Math.toRadians(lat2 - lat1)
        val dLon = Math.toRadians(lon2 - lon1)
        val a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
        val c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        return earthRadius * c
    }

    private fun splitIntoSentences(text: String): List<String> {
        val sentences = mutableListOf<String>()
        
        // Î¨∏Ïû• Íµ¨Î∂ÑÏûê
        val sentenceDelimiters = "[.!?]".toRegex()
        val parts = text.split(sentenceDelimiters)
        
        if (parts.size > 1) {
            // Î¨∏Ïû• Íµ¨Î∂ÑÏûêÍ∞Ä ÏûàÏúºÎ©¥ Í∑∏ÎåÄÎ°ú Î∂ÑÌï†
            for (part in parts) {
                if (part.trim().isNotEmpty()) {
                    sentences.add(part.trim())
                }
            }
        } else {
            // ÏâºÌëúÎ°ú Î∂ÑÌï† ÏãúÎèÑ
            val commaDelimited = text.split(",")
            if (commaDelimited.size > 1) {
                for (part in commaDelimited) {
                    if (part.trim().isNotEmpty()) {
                        sentences.add(part.trim())
                    }
                }
            } else {
                // Í∏∏Ïù¥Ïóê Îî∞Îùº ÏûÑÏùòÎ°ú Î∂ÑÌï†
                val maxLength = 20
                var remaining = text
                while (remaining.length > maxLength) {
                    // Í≥µÎ∞±ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ï†ÅÏ†àÌïú Î∂ÑÌï† ÏßÄÏ†ê Ï∞æÍ∏∞
                    var cutPoint = maxLength
                    while (cutPoint > 0 && remaining[cutPoint] != ' ') {
                        cutPoint--
                    }
                    // Í≥µÎ∞±ÏùÑ Ï∞æÏßÄ Î™ªÌñàÏúºÎ©¥ Í∑∏ÎÉ• maxLengthÏóêÏÑú ÏûêÎ•¥Í∏∞
                    if (cutPoint == 0) cutPoint = maxLength
                    
                    sentences.add(remaining.substring(0, cutPoint).trim())
                    remaining = remaining.substring(cutPoint).trim()
                }
                if (remaining.isNotEmpty()) {
                    sentences.add(remaining)
                }
            }
        }
        
        return sentences.filter { it.isNotEmpty() }
    }

    private fun handleBoardingComplete() {
        try {
            // ÏïåÎ¶º Îß§ÎãàÏ†Ä Í∞ÄÏ†∏Ïò§Í∏∞
            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            
            // ÏßÑÌñâ Ï§ëÏù∏ ÏïåÎ¶º Î™®Îëê Ï†úÍ±∞
            notificationManager.cancelAll()
            
            // TTS Ï§ëÏßÄ
            _methodChannel?.invokeMethod("stopTTS", null)
            
            // ÏäπÏ∞® ÏôÑÎ£å Î©îÏãúÏßÄ ÌëúÏãú
            Toast.makeText(
                this,
                "ÏäπÏ∞®Í∞Ä ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. ÏïåÎ¶ºÏù¥ Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.",
                Toast.LENGTH_SHORT
            ).show()
            
            Log.d(TAG, "‚úÖ ÏäπÏ∞® ÏôÑÎ£å Ï≤òÎ¶¨Îê®")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ÏäπÏ∞® ÏôÑÎ£å Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò: ${e.message}")
        }
    }
}

fun BusRoute.toMap(): Map<String, Any?> {
    return mapOf(
        "id" to id,
        "routeNo" to routeNo,
        "startPoint" to startPoint,
        "endPoint" to endPoint,
        "routeDescription" to routeDescription
    )
}