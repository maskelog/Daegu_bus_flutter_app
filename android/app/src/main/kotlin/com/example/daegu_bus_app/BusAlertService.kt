package com.example.daegu_bus_app

import io.flutter.plugin.common.MethodChannel
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.media.AudioAttributes
import android.media.AudioManager
import android.net.Uri
import android.os.Build
import android.os.IBinder
import android.util.Log
import android.graphics.Color
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import kotlinx.coroutines.*
import java.util.Timer
import java.util.TimerTask
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import android.media.AudioManager.OnAudioFocusChangeListener
import android.media.AudioFocusRequest
import android.os.Bundle
import android.app.Notification
import java.util.Locale
import java.text.SimpleDateFormat
import java.util.Date
import org.json.JSONArray
import org.json.JSONObject
import io.flutter.embedding.engine.FlutterEngine
import java.util.concurrent.ConcurrentHashMap
import kotlin.math.min

class BusAlertService : Service() {
    companion object {
        private const val TAG = "BusAlertService"
        private const val CHANNEL_BUS_ALERTS = "bus_alerts"
        private const val CHANNEL_BUS_ONGOING = "bus_ongoing"
        const val ONGOING_NOTIFICATION_ID = 10000

        // ÏÑ§Ï†ï Í¥ÄÎ†® ÏÉÅÏàò
        private const val PREF_ALARM_SOUND = "alarm_sound_preference"
        private const val PREF_ALARM_SOUND_FILENAME = "alarm_sound_filename"
        private const val PREF_ALARM_USE_TTS = "alarm_use_tts"
        private const val DEFAULT_ALARM_SOUND = "alarm_sound"
        private const val PREF_SPEAKER_MODE = "speaker_mode"
        private const val PREF_NOTIFICATION_DISPLAY_MODE_KEY = "notificationDisplayMode"
        private const val PREF_TTS_VOLUME = "tts_volume"

        // Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÉÅÏàò
        private const val OUTPUT_MODE_HEADSET = 0
        private const val OUTPUT_MODE_SPEAKER = 1
        private const val OUTPUT_MODE_AUTO = 2

        // ÏïåÎ¶º ÌëúÏãú Î™®Îìú ÏÉÅÏàò
        private const val DISPLAY_MODE_ALARMED_ONLY = 0
        private const val DISPLAY_MODE_ALL_BUSES = 1

        @Volatile
        private var instance: BusAlertService? = null

        fun getInstance(context: Context): BusAlertService {
            return instance ?: synchronized(this) {
                instance ?: BusAlertService().also {
                    instance = it
                }
            }
        }

        const val ACTION_START_TRACKING_FOREGROUND = "com.example.daegu_bus_app.action.START_TRACKING_FOREGROUND"
        const val ACTION_UPDATE_TRACKING = "com.example.daegu_bus_app.action.UPDATE_TRACKING"
        const val ACTION_STOP_BUS_ALERT_TRACKING = "com.example.daegu_bus_app.action.STOP_BUS_ALERT_TRACKING"
    }

    // ÏÑúÎπÑÏä§ ÏÉÅÌÉú Î∞è ÏÑ§Ï†ï
    private var _methodChannel: MethodChannel? = null
    private val serviceScope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    // ÏÑúÎπÑÏä§ Ïª®ÌÖçÏä§Ìä∏ Ï†ÄÏû•
    private var mApplicationContext: Context? = null

    // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞ Ìï®Ïàò
    private fun getAppContext(): Context {
        return mApplicationContext ?: this
    }
    private lateinit var busApiService: BusApiService
    private var monitoringJob: Job? = null
    private val monitoredRoutes = ConcurrentHashMap<String, Pair<String, String>>()
    private var timer = Timer()
    private var ttsJob: Job? = null
    private var ttsEngine: TextToSpeech? = null
    private var isTtsInitialized = false
    private var isTtsTrackingActive = false
    private var isInForeground = false // Track foreground state - Correctly declared

    // Settings (loaded in initialize)
    private var currentAlarmSound = DEFAULT_ALARM_SOUND
    private var useTextToSpeech = false
    private var audioOutputMode = OUTPUT_MODE_AUTO
    private var notificationDisplayMode = DISPLAY_MODE_ALARMED_ONLY
    private var ttsVolume: Float = 1.0f
    private var audioManager: AudioManager? = null

    val isInTrackingMode: Boolean
        get() = monitoredRoutes.isNotEmpty()

    private val cachedBusInfo = ConcurrentHashMap<String, BusInfo>()
    private val arrivingSoonNotified = ConcurrentHashMap.newKeySet<String>()

    data class BusInfo(
        val busNumber: String,
        val routeId: String,
        val estimatedTime: String,
        val currentStation: String?,
        val remainingStations: String,
        var lastUpdateTime: Long? = null
    ) {
         fun getRemainingMinutes(): Int {
             return when {
                 estimatedTime == "Í≥ß ÎèÑÏ∞©" -> 0
                 estimatedTime == "Ïö¥ÌñâÏ¢ÖÎ£å" -> -1
                 estimatedTime.contains("Î∂Ñ") -> estimatedTime.filter { it.isDigit() }.toIntOrNull() ?: -1
                 else -> -1
             }
         }
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "üîî BusAlertService onCreate")
        // Initialize components using context
        busApiService = BusApiService(this)
        audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
        createNotificationChannels()
        loadSettings()
        initializeTts()
    }

    fun initialize(context: Context? = null, flutterEngine: FlutterEngine? = null) {
        Log.d(TAG, "üîî BusAlertService initialize (Engine: ${flutterEngine != null})")
        try {
            // ÏïàÏ†ÑÌïòÍ≤å context Ï†ÄÏû•
            if (context != null) {
                // Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïª®ÌÖçÏä§Ìä∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏÑúÎπÑÏä§Í∞Ä Ï¢ÖÎ£åÎêòÏñ¥ÎèÑ Ïú†Ìö®Ìïú Ïª®ÌÖçÏä§Ìä∏ Ïú†ÏßÄ
                val appContext = context.applicationContext
                if (appContext != null) {
                    // Ïù¥ ÏÑúÎπÑÏä§Ïùò Ïª®ÌÖçÏä§Ìä∏Î•º Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïª®ÌÖçÏä§Ìä∏Î°ú ÏóÖÎç∞Ïù¥Ìä∏
                    mApplicationContext = appContext
                    Log.d(TAG, "üîî Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ïª®ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
                }
            }

            // Î©îÏÑúÎìú Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî
            if (_methodChannel == null && flutterEngine != null) {
                initializeMethodChannel(flutterEngine)
            }

            // ÏÑ§Ï†ï Î∞è ÏïåÎ¶º Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî
            loadSettings()
            createNotificationChannels()
            // TTS is initialized in onCreate
            Log.d(TAG, "‚úÖ BusAlertService Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        } catch (e: Exception) {
            Log.e(TAG, "üîî BusAlertService Ï¥àÍ∏∞Ìôî Ïò§Î•ò: ${e.message}", e)
        }
    }

    private fun initializeMethodChannel(flutterEngine: FlutterEngine?) {
        _methodChannel = flutterEngine?.dartExecutor?.binaryMessenger?.let {
            MethodChannel(it, "com.example.daegu_bus_app/bus_api").also {
                 Log.d(TAG, "üîå Î©îÏÑúÎìú Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (FlutterEngine ÏÇ¨Ïö©)")
            }
        } ?: run {
            Log.w(TAG, "üîå Î©îÏÑúÎìú Ï±ÑÎÑê Ï¥àÍ∏∞Ìôî Ïã§Ìå® - FlutterEngine ÏóÜÏùå")
            null
        }
    }

    private fun initializeTts() {
        Log.d(TAG, "üîä TTS ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏãúÏûë")
        try {
            ttsEngine?.stop()
            ttsEngine?.shutdown()
            // Use context for TTS initialization
            ttsEngine = TextToSpeech(this) { status ->
                if (status == TextToSpeech.SUCCESS) {
                    isTtsInitialized = true
                    configureTts()
                } else {
                    isTtsInitialized = false
                    Log.e(TAG, "‚ùå TTS ÏóîÏßÑ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: $status")
                }
            }
        } catch (e: Exception) {
            isTtsInitialized = false
            Log.e(TAG, "‚ùå TTS ÏóîÏßÑ ÏÉùÏÑ± Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", e)
        }
    }

    private fun configureTts() {
        if (!isTtsInitialized || ttsEngine == null) {
             Log.e(TAG,"‚ùå TTS ÏÑ§Ï†ï ÏãúÎèÑ - ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏïàÎê®")
             return
        }
        try {
            val result = ttsEngine?.setLanguage(Locale.KOREAN)
            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                Log.e(TAG, "‚ùå TTS ÌïúÍµ≠Ïñ¥ ÏßÄÏõê ÏïàÎê®/Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå (Í≤∞Í≥º: $result)")
                isTtsInitialized = false
            } else {
                ttsEngine?.apply {
                    setSpeechRate(1.0f)
                    setPitch(1.0f)
                    setOnUtteranceProgressListener(createTtsListener())
                }
                Log.d(TAG, "üîä TTS ÏóîÏßÑ ÏÑ§Ï†ï ÏôÑÎ£å (ÌïúÍµ≠Ïñ¥)")
            }
        } catch (e: Exception) {
            isTtsInitialized = false
            Log.e(TAG, "‚ùå TTS Ïñ∏Ïñ¥ Î∞è ÏÜçÏÑ± ÏÑ§Ï†ï Ï§ë Ïò§Î•ò: ${e.message}", e)
        }
    }

     // Declare the listener as a member variable
     private val audioFocusListener = OnAudioFocusChangeListener { focusChange ->
         serviceScope.launch {
             when (focusChange) {
                AudioManager.AUDIOFOCUS_LOSS -> {
                    Log.d(TAG, "üîä Ïò§ÎîîÏò§ Ìè¨Ïª§Ïä§ ÏôÑÏ†Ñ ÏÜêÏã§ -> TTS Ï§ëÏßÄ")
                    stopTtsTracking(forceStop = true)
                }
                AudioManager.AUDIOFOCUS_LOSS_TRANSIENT,
                AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                    Log.d(TAG, "üîä ÏùºÏãúÏ†Å Ïò§ÎîîÏò§ Ìè¨Ïª§Ïä§ ÏÜêÏã§ -> TTS Ï§ëÏßÄ")
                    if (isTtsInitialized && ttsEngine != null) {
                        ttsEngine?.stop()
                    }
                }
                 AudioManager.AUDIOFOCUS_GAIN -> {
                      Log.d(TAG, "üîä Ïò§ÎîîÏò§ Ìè¨Ïª§Ïä§ ÌöçÎìù/Î≥µÍµ¨")
                 }
             }
         }
     }

    private fun createTtsListener() = object : UtteranceProgressListener() {
        override fun onStart(utteranceId: String?) {
            Log.d(TAG, "üîä TTS Î∞úÌôî ÏãúÏûë: $utteranceId")
        }

        override fun onDone(utteranceId: String?) {
            Log.d(TAG, "üîä TTS Î∞úÌôî ÏôÑÎ£å: $utteranceId")
            audioManager?.abandonAudioFocus(audioFocusListener)
        }

        @Deprecated("Deprecated in Java", ReplaceWith("onError(utteranceId, errorCode)"))
        override fun onError(utteranceId: String?) {
             onError(utteranceId, -1)
        }

        override fun onError(utteranceId: String?, errorCode: Int) {
            Log.e(TAG, "‚ùå TTS Î∞úÌôî Ïò§Î•ò: $utteranceId, errorCode: $errorCode")
            audioManager?.abandonAudioFocus(audioFocusListener)
        }
    }

    private fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            try {
                // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                val context = getAppContext()
                val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                createBusAlertsChannel(notificationManager)
                createBusOngoingChannel(notificationManager)
                Log.d(TAG, "üîî ÏïåÎ¶º Ï±ÑÎÑê ÏÉùÏÑ±/ÌôïÏù∏ ÏôÑÎ£å")
            } catch (e: Exception) {
                Log.e(TAG, "üîî ÏïåÎ¶º Ï±ÑÎÑê ÏÉùÏÑ± Ïò§Î•ò: ${e.message}", e)
            }
        }
    }

    private fun createBusAlertsChannel(notificationManager: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channelId = CHANNEL_BUS_ALERTS
            if (notificationManager.getNotificationChannel(channelId) == null) {
                 val channel = NotificationChannel(channelId, "Î≤ÑÏä§ ÎèÑÏ∞© ÏïåÎ¶º", NotificationManager.IMPORTANCE_HIGH)
                 .apply {
                    description = "Î≤ÑÏä§Í∞Ä Ï†ïÎ•òÏû•Ïóê ÎèÑÏ∞©ÌïòÍ∏∞ ÏßÅÏ†Ñ ÏïåÎ¶º"
                    enableLights(true)
                    lightColor = Color.RED
                    enableVibration(true)
                    vibrationPattern = longArrayOf(0, 500, 200, 500)
                 }
                 notificationManager.createNotificationChannel(channel)
                 Log.d(TAG,"'$channelId' Ï±ÑÎÑê ÏÉùÏÑ±Îê®")
            } else {
                 Log.d(TAG,"'$channelId' Ï±ÑÎÑê Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®")
            }
             updateChannelSound(notificationManager, channelId)
        }
    }

     private fun updateChannelSound(notificationManager: NotificationManager, channelId: String) {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             val channel = notificationManager.getNotificationChannel(channelId)
             if (channel != null && channel.importance >= NotificationManager.IMPORTANCE_DEFAULT) {
                 val soundUri = if (currentAlarmSound.isNotEmpty()) {
                     // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                     val context = getAppContext()
                     Uri.parse("android.resource://${context.packageName}/raw/$currentAlarmSound")
                 } else { null }
                 val audioAttributes = AudioAttributes.Builder()
                     .setUsage(AudioAttributes.USAGE_ALARM)
                     .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                     .build()
                 channel.setSound(soundUri, audioAttributes)
                 notificationManager.createNotificationChannel(channel)
                 Log.d(TAG,"'$channelId' Ï±ÑÎÑê ÏÇ¨Ïö¥Îìú ÏóÖÎç∞Ïù¥Ìä∏Îê®: $currentAlarmSound")
             }
         }
     }

    private fun createBusOngoingChannel(notificationManager: NotificationManager) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             val channelId = CHANNEL_BUS_ONGOING
             if (notificationManager.getNotificationChannel(channelId) == null) {
                 // applicationContextÍ∞Ä nullÏù∏ Í≤ΩÏö∞ ÏÑúÎπÑÏä§ Ïª®ÌÖçÏä§Ìä∏ ÏÇ¨Ïö©
                 val context = applicationContext ?: this
                 val channel = NotificationChannel(channelId, "Ïã§ÏãúÍ∞Ñ Î≤ÑÏä§ Ï∂îÏ†Å", NotificationManager.IMPORTANCE_DEFAULT)
                 .apply {
                    description = "ÏÑ†ÌÉùÌïú Î≤ÑÏä§Ïùò ÏúÑÏπò Ïã§ÏãúÍ∞Ñ Ï∂îÏ†Å"
                    setSound(null, null)
                    enableVibration(false)
                    enableLights(true)
                    // Ïª®ÌÖçÏä§Ìä∏Î•º ÏÇ¨Ïö©ÌïòÏó¨ ÏÉâÏÉÅ Í∞ÄÏ†∏Ïò§Í∏∞
                    lightColor = ContextCompat.getColor(context, R.color.tracking_color)
                    setShowBadge(true)
                    lockscreenVisibility = Notification.VISIBILITY_PUBLIC
                 }
                 notificationManager.createNotificationChannel(channel)
                 Log.d(TAG,"'$channelId' Ï±ÑÎÑê ÏÉùÏÑ±Îê®")
             } else {
                  Log.d(TAG,"'$channelId' Ï±ÑÎÑê Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®")
             }
        }
    }

    private fun checkNotificationPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            try {
                // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                val context = getAppContext()
                val hasPermission = NotificationManagerCompat.from(context).areNotificationsEnabled()
                Log.d(TAG, "Android 13+ ÏïåÎ¶º Í∂åÌïú ÏÉÅÌÉú: ${if(hasPermission) "ÌóàÏö©Îê®" else "ÌïÑÏöîÌï®/Í±∞Î∂ÄÎê®"}")
            } catch (e: Exception) {
                Log.e(TAG, "ÏïåÎ¶º Í∂åÌïú ÌôïÏù∏ Ïò§Î•ò: ${e.message}")
            }
        }
    }

    fun registerBusArrivalReceiver() {
        serviceScope.launch {
            if (monitoredRoutes.isEmpty()) {
                Log.w(TAG, "üîî Î™®ÎãàÌÑ∞ÎßÅÌï† ÎÖ∏ÏÑ† ÏóÜÏùå. ÌÉÄÏù¥Î®∏ ÏãúÏûë Ïïà Ìï®.")
                stopMonitoringTimer()
                return@launch
            }
            if (monitoringJob == null || monitoringJob?.isActive != true) {
                 Log.d(TAG, "üîî Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥ Î™®ÎãàÌÑ∞ÎßÅ ÌÉÄÏù¥Î®∏ ÏãúÏûë (10Ï¥à Í∞ÑÍ≤©)")
                 stopMonitoringTimer()
                 timer = Timer()
                 monitoringJob = launch {
                    timer.scheduleAtFixedRate(object : TimerTask() {
                        override fun run() {
                             if (monitoredRoutes.isNotEmpty()) {
                                  // Use serviceScope.launch for checkBusArrivals
                                  serviceScope.launch { checkBusArrivals() }
                             } else {
                                  Log.d(TAG, "üîî Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† ÏóÜÏñ¥ ÌÉÄÏù¥Î®∏ ÏûëÏóÖ Ï§ëÏßÄ.")
                                  this.cancel()
                                  stopMonitoringTimer()
                             }
                        }
                    }, 0, 10000)
                 }
                 _methodChannel?.invokeMethod("onBusMonitoringStarted", null)
            } else {
                 Log.d(TAG,"üîî Î™®ÎãàÌÑ∞ÎßÅ ÌÉÄÏù¥Î®∏ Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ë.")
            }
        }
    }

    // Make sure this function is defined within the class
    private fun stopMonitoringTimer() {
         serviceScope.launch {
              if (monitoringJob?.isActive == true) {
                   Log.d(TAG,"üîî Î™®ÎãàÌÑ∞ÎßÅ ÏûëÏóÖ(Job) Ï∑®ÏÜå ÏãúÎèÑ")
                   monitoringJob?.cancel()
              }
              monitoringJob = null
              try {
                   timer.cancel()
                   Log.d(TAG,"üîî Î™®ÎãàÌÑ∞ÎßÅ ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå ÏôÑÎ£å")
              } catch (e: IllegalStateException) {
                   Log.d(TAG,"üîî Î™®ÎãàÌÑ∞ÎßÅ ÌÉÄÏù¥Î®∏ Ïù¥ÎØ∏ Ï∑®ÏÜåÎê® ÎòêÎäî Ïò§Î•ò: ${e.message}")
              }
         }
    }

    private suspend fun checkBusArrivals() {
         if (monitoredRoutes.isEmpty()) {
            Log.d(TAG, "üöå [Timer] Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† ÏóÜÏùå, ÌôïÏù∏ Ï§ëÎã®")
            stopMonitoringTimer()
            stopTrackingIfIdle()
            return
         }
        Log.d(TAG, "üöå [Timer] Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥ ÌôïÏù∏ ÏãúÏûë (${monitoredRoutes.size}Í∞ú ÎÖ∏ÏÑ†)")
        try {
             val allBusInfos = withContext(Dispatchers.IO) { collectBusArrivals() }
             withContext(Dispatchers.Main) { updateNotifications(allBusInfos) }
        } catch (e: CancellationException) {
             Log.d(TAG,"üöå [Timer] Î≤ÑÏä§ ÎèÑÏ∞© ÌôïÏù∏ ÏûëÏóÖ Ï∑®ÏÜåÎê®")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå [Timer] Î≤ÑÏä§ ÎèÑÏ∞© ÌôïÏù∏ Ï§ë Ïò§Î•ò: ${e.message}", e)
        }
    }

    private suspend fun collectBusArrivals(): List<Triple<String, String, BusInfo>> {
        val allBusInfos = mutableListOf<Triple<String, String, BusInfo>>()
        val routesToCheck = monitoredRoutes.toMap()
        for ((routeId, stationInfo) in routesToCheck) {
            val (stationId, stationName) = stationInfo
            try {
                 if (!monitoredRoutes.containsKey(routeId)) {
                      Log.d(TAG, "üöå $routeId ÎÖ∏ÏÑ† Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄÎê®, API Ìò∏Ï∂ú Í±¥ÎÑàÎúÄ")
                      continue
                 }
                val arrivalInfo = busApiService.getBusArrivalInfoByRouteId(stationId, routeId)
                if (arrivalInfo?.bus?.isNotEmpty() == true) {
                    processBusArrivals(arrivalInfo.bus, routeId, stationName, allBusInfos)
                } else {
                    Log.d(TAG, "üöå [API Check] $routeId @ $stationName: ÎèÑÏ∞© ÏòàÏ†ï Î≤ÑÏä§ Ï†ïÎ≥¥ ÏóÜÏùå")
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå [API] $routeId ÎÖ∏ÏÑ† Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë Ïò§Î•ò: ${e.message}")
            }
        }
        return allBusInfos
    }

    private fun processBusArrivals(
        buses: List<StationArrivalOutput.BusInfo>,
        routeId: String,
        stationName: String,
        allBusInfos: MutableList<Triple<String, String, BusInfo>>
    ) {
        for (bus in buses) {
             val busInfo = BusInfo(
                busNumber = bus.busNumber, routeId = routeId,
                estimatedTime = bus.estimatedTime, currentStation = bus.currentStation,
                remainingStations = bus.remainingStations, lastUpdateTime = System.currentTimeMillis()
             )
             val remainingTime = busInfo.getRemainingMinutes()
             val busNo = busInfo.busNumber
             val currentStation = busInfo.currentStation
             val remainingStops = busInfo.remainingStations.replace("[^0-9]".toRegex(), "").toIntOrNull() ?: -1
            updateBusCache(busNo, routeId, busInfo)
            allBusInfos.add(Triple(busNo, stationName, busInfo))
             checkArrivingSoon(
                routeId = routeId, stationId = monitoredRoutes[routeId]?.first ?: "",
                busNo = busNo, stationName = stationName, remainingTime = remainingTime,
                remainingStops = remainingStops, currentStation = currentStation
             )
            Log.d(TAG, "üöå [API Process] $busNo @ $stationName: ÎÇ®ÏùÄ ÏãúÍ∞Ñ $remainingTime Î∂Ñ, ÌòÑÏû¨ ÏúÑÏπò $currentStation, ÎÇ®ÏùÄ Ï†ïÎ•òÏû• $remainingStops")
        }
    }

    private fun updateBusCache(busNo: String, routeId: String, bus: BusInfo) {
        val cacheKey = "$busNo-$routeId"
        cachedBusInfo[cacheKey] = bus
    }

    private fun checkArrivingSoon(
        routeId: String,
        stationId: String,
        busNo: String,
        stationName: String,
        remainingTime: Int,
        remainingStops: Int,
        currentStation: String?
    ) {
        val shouldTriggerArrivingSoon = (remainingStops == 1 && remainingTime in 0..3)
        val currentNotificationKey = "${routeId}_${stationId}_$busNo"
        if (shouldTriggerArrivingSoon && arrivingSoonNotified.add(currentNotificationKey)) {
            Log.i(TAG, "‚úÖ [Arriving Soon] Ï°∞Í±¥ ÎßåÏ°± & Ï≤´ ÏïåÎ¶º Î∞úÏÉù: $currentNotificationKey")
             serviceScope.launch { showBusArrivingSoon(busNo, stationName, currentStation) }
             stopTtsTracking(routeId = routeId, stationId = stationId)
        } else if (shouldTriggerArrivingSoon) {
             Log.d(TAG,"‚òëÔ∏è [Arriving Soon] Ï°∞Í±¥ ÎßåÏ°±ÌñàÏúºÎÇò Ïù¥ÎØ∏ ÏïåÎ¶º: $currentNotificationKey")
        }
    }

    private fun updateNotifications(allBusInfos: List<Triple<String, String, BusInfo>>) {
        if (monitoredRoutes.isEmpty()) {
            Log.d(TAG, "Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ†Ïù¥ ÏóÜÏñ¥ ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ Î∞è ÏÑúÎπÑÏä§ Ï†ïÎ¶¨")
            stopTracking()
            return
        }
        // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
        val context = getAppContext()
        val notificationManager = NotificationManagerCompat.from(context)
        if (allBusInfos.isEmpty()) {
            Log.d(TAG,"ÎèÑÏ∞© ÏòàÏ†ï Î≤ÑÏä§ Ï†ïÎ≥¥ ÏóÜÏùå. ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ (Ï†ïÎ≥¥ ÏóÜÏùå)")
            updateEmptyNotification()
        } else {
            val sortedBusInfos = allBusInfos.sortedBy { it.third.getRemainingMinutes().let { time -> if (time < 0) Int.MAX_VALUE else time } }
            val displayBusTriple = sortedBusInfos.first()
            val (busNo, stationName, busInfo) = displayBusTriple
            val remainingTime = busInfo.getRemainingMinutes()
            val routeId = busInfo.routeId
            val allBusesSummary = if (notificationDisplayMode == DISPLAY_MODE_ALL_BUSES) {
                formatAllArrivalsForNotification(sortedBusInfos)
            } else null
            showOngoingBusTracking(
                busNo = busNo, stationName = stationName, remainingMinutes = remainingTime,
                currentStation = busInfo.currentStation, isUpdate = true,
                notificationId = ONGOING_NOTIFICATION_ID, allBusesSummary = allBusesSummary,
                routeId = routeId
            )
            updateFlutterUI(busNo, busInfo.routeId, remainingTime, busInfo.currentStation)
        }
    }

    private fun updateEmptyNotification() {
         if (monitoredRoutes.isEmpty()) {
              cancelOngoingTracking()
              stopTrackingIfIdle()
              return
         }
         val firstRouteEntry = monitoredRoutes.entries.firstOrNull()
         val routeId = firstRouteEntry?.key ?: "Ïïå Ïàò ÏóÜÏùå"
         val stationName = firstRouteEntry?.value?.second ?: "Ïïå Ïàò ÏóÜÏùå"
         showOngoingBusTracking(
            busNo = "-", stationName = stationName, remainingMinutes = -1,
            currentStation = "ÎèÑÏ∞© Ï†ïÎ≥¥ ÏóÜÏùå", isUpdate = true,
            notificationId = ONGOING_NOTIFICATION_ID, routeId = routeId
         )
    }

    private fun updateFlutterUI(busNo: String, routeId: String, remainingTime: Int, currentStation: String?) {
         if (_methodChannel == null) {
              Log.w(TAG, "Flutter UI ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÎèÑ - MethodChannel Ï¥àÍ∏∞Ìôî ÏïàÎê®")
              return
         }
        try {
            _methodChannel?.invokeMethod("onBusLocationUpdated", mapOf(
                "busNo" to busNo, "routeId" to routeId, "remainingMinutes" to remainingTime,
                "currentStation" to (currentStation ?: "Ï†ïÎ≥¥ ÏóÜÏùå")
            ))
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Flutter UI ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: ${e.message}")
        }
    }

    private fun showBusArrivalNotification(stationName: String, busNo: String, remainingTime: Int) {
        try {
            // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            val context = getAppContext()
            val notificationManager = NotificationManagerCompat.from(context)
            val channelId = CHANNEL_BUS_ALERTS
            val notificationId = System.currentTimeMillis().toInt()
            val title = "üöå $busNo Î≤à Î≤ÑÏä§ ÎèÑÏ∞© ÏûÑÎ∞ï!"
            val content = "$stationName Ï†ïÎ•òÏû• ${if (remainingTime == 0) "Í≥ß ÎèÑÏ∞©" else "ÏïΩ $remainingTime Î∂Ñ ÌõÑ ÎèÑÏ∞©"}"
            // ÏïåÎ¶º ÌÅ¥Î¶≠ Ïãú Ïù¥ÎèôÌï† Ïù∏ÌÖêÌä∏ ÏÉùÏÑ±
            val intent = Intent(context, MainActivity::class.java).apply {
                 flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
            }
             val pendingIntent = PendingIntent.getActivity(
                 context, notificationId, intent,
                 PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
             )
            // ÏïåÎ¶º ÎπåÎçî ÏÉùÏÑ±
            val builder = NotificationCompat.Builder(context, channelId)
                .setSmallIcon(R.drawable.ic_bus_notification)
                .setContentTitle(title).setContentText(content)
                .setPriority(NotificationCompat.PRIORITY_HIGH)
                .setCategory(NotificationCompat.CATEGORY_ALARM)
                .setAutoCancel(true).setContentIntent(pendingIntent)
                .setDefaults(NotificationCompat.DEFAULT_VIBRATE)
            if (!useTextToSpeech && currentAlarmSound.isNotEmpty()) {
                 // ÏïåÎ¶º ÏùåÏÑ± URI ÏÉùÏÑ±
                 val soundUri = Uri.parse("android.resource://${context.packageName}/raw/$currentAlarmSound")
                 builder.setSound(soundUri)
            }
            notificationManager.notify(notificationId, builder.build())
            Log.d(TAG, "üîî ÎèÑÏ∞© ÏïåÎ¶º ÌëúÏãúÎê® (ID: $notificationId): $busNo Î≤à ($remainingTime Î∂Ñ)")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ÎèÑÏ∞© ÏïåÎ¶º ÌëúÏãú Ï§ë Ïò§Î•ò: ${e.message}")
        }
    }

    fun addMonitoredRoute(routeId: String, stationId: String, stationName: String) {
        if (routeId.isBlank() || stationId.isBlank() || stationName.isBlank()) {
            Log.e(TAG, "üîî Î™®ÎãàÌÑ∞ÎßÅ Ï∂îÍ∞Ä Ïã§Ìå® - Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌååÎùºÎØ∏ÌÑ∞: R=$routeId, S=$stationId, N=$stationName")
            return
        }
        Log.d(TAG, "üîî Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† Ï∂îÍ∞Ä ÏöîÏ≤≠: R=$routeId, S=$stationId, N=$stationName")
        val wasEmpty = monitoredRoutes.isEmpty()
        monitoredRoutes[routeId] = Pair(stationId, stationName)
        Log.i(TAG, "üîî Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† Ï∂îÍ∞Ä ÏôÑÎ£å: ${monitoredRoutes.size}Í∞ú Ï∂îÏ†Å Ï§ë")
        if (wasEmpty) {
            registerBusArrivalReceiver()
        } else {
            serviceScope.launch { checkBusArrivals() }
        }
    }

    fun getMonitoredRoutesCount(): Int = monitoredRoutes.size

    fun showNotification(
        id: Int, busNo: String, stationName: String, remainingMinutes: Int,
        currentStation: String? = null, payload: String? = null, routeId: String? = null
    ) {
         Log.d(TAG,"showNotification Ìò∏Ï∂úÎê® (Alert Ïö©ÎèÑ): ID=$id, Bus=$busNo, Station=$stationName")
         showBusArrivalNotification(stationName, busNo, remainingMinutes)
    }

    fun showOngoingBusTracking(
        busNo: String, stationName: String, remainingMinutes: Int,
        currentStation: String?, isUpdate: Boolean = false,
        notificationId: Int = ONGOING_NOTIFICATION_ID, allBusesSummary: String? = null,
        routeId: String? = null
    ) {
        try {
            if (routeId == null) {
                 Log.e(TAG, "üöå routeIdÍ∞Ä nullÏûÖÎãàÎã§. Ongoing ÏïåÎ¶º ÌëúÏãú/ÏóÖÎç∞Ïù¥Ìä∏ Î∂àÍ∞Ä.")
                 return
            }
            Log.d(TAG, "üöå Ongoing ÏïåÎ¶º ÌëúÏãú/ÏóÖÎç∞Ïù¥Ìä∏: Bus=$busNo, Route=$routeId, Station=$stationName, Mins=$remainingMinutes, Update=$isUpdate")

            val currentTime = SimpleDateFormat("HH:mm", Locale.getDefault()).format(Date())
            val title = if (monitoredRoutes.size > 1) "$busNo Î≤à Î≤ÑÏä§ ‚Üí $stationName" else "$busNo Î≤à Î≤ÑÏä§ Ïã§ÏãúÍ∞Ñ Ï∂îÏ†Å"
            val bodyText = if (remainingMinutes < 0) "ÎèÑÏ∞© Ï†ïÎ≥¥ ÏóÜÏùå ($currentTime)"
                           else if (remainingMinutes == 0) "$stationName Ïóê Í≥ß ÎèÑÏ∞©!"
                           else "ÏïΩ $remainingMinutes Î∂Ñ ÌõÑ $stationName ÎèÑÏ∞©"
            val bigBodyText = buildString {
                if (remainingMinutes < 0) append("$busNo Î≤à Î≤ÑÏä§ - ÎèÑÏ∞© Ï†ïÎ≥¥ ÏóÜÏùå")
                else if (remainingMinutes == 0) append("‚úÖ $busNo Î≤à Î≤ÑÏä§Í∞Ä $stationName Ï†ïÎ•òÏû•Ïóê Í≥ß ÎèÑÏ∞©Ìï©ÎãàÎã§!")
                else {
                     append("‚è±Ô∏è $busNo Î≤à Î≤ÑÏä§Í∞Ä $stationName Ï†ïÎ•òÏû•ÍπåÏßÄ ÏïΩ $remainingMinutes Î∂Ñ ÎÇ®ÏïòÏäµÎãàÎã§.")
                     if (!currentStation.isNullOrEmpty()) append("\nüìç ÌòÑÏû¨ ÏúÑÏπò: $currentStation")
                }
                if (allBusesSummary != null) append("\n\n--- Îã§Î•∏ Î≤ÑÏä§ ---\n$allBusesSummary")
            }

            // Use applicationContext
            val contentIntent = Intent(applicationContext, MainActivity::class.java).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
                putExtra("NOTIFICATION_ID", notificationId)
                putExtra("routeId", routeId)
                putExtra("stationName", stationName)
                putExtra("stationId", monitoredRoutes[routeId]?.first)
            }
            val pendingContentIntent = PendingIntent.getActivity(
                // Use applicationContext
                applicationContext, notificationId,
                contentIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )

            // Stop Intent - Ensure it uses applicationContext and correct action
            // Use applicationContext
            val stopTrackingIntent = Intent(applicationContext, BusAlertService::class.java).apply {
                action = ACTION_STOP_BUS_ALERT_TRACKING
                putExtra("routeId", routeId)
                putExtra("busNo", busNo)
                putExtra("stationName", stationName)
                putExtra("stationId", monitoredRoutes[routeId]?.first)
            }
            val stopRequestCode = notificationId + (routeId.hashCode() % 10000) + 1
            val stopTrackingPendingIntent = PendingIntent.getService(
                // Use applicationContext
                applicationContext, stopRequestCode,
                stopTrackingIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )

            // Use applicationContext
            val builder = NotificationCompat.Builder(applicationContext, CHANNEL_BUS_ONGOING)
                .setSmallIcon(R.drawable.ic_bus_notification)
                .setContentTitle(title).setContentText(bodyText)
                .setStyle(NotificationCompat.BigTextStyle().bigText(bigBodyText))
                .setPriority(NotificationCompat.PRIORITY_DEFAULT)
                .setCategory(NotificationCompat.CATEGORY_SERVICE)
                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                 // Use applicationContext
                .setColor(ContextCompat.getColor(applicationContext, R.color.tracking_color))
                .setColorized(true).setOngoing(true).setAutoCancel(false)
                .setOnlyAlertOnce(true).setContentIntent(pendingContentIntent)
                .addAction(R.drawable.ic_stop, "Ï∂îÏ†Å Ï§ëÏßÄ", stopTrackingPendingIntent)
                .setWhen(System.currentTimeMillis()).setShowWhen(true)

            val progress = if (remainingMinutes < 0) 0
                           else if (remainingMinutes == 0) 100
                           else if (remainingMinutes > 30) 0
                           else ((30 - remainingMinutes) * 100 / 30)
            builder.setProgress(100, progress.coerceIn(0, 100), false)

            val notification = builder.build()
            // Use applicationContext
            val notificationManager = NotificationManagerCompat.from(applicationContext)

            if (!isInForeground) {
                 try {
                      startForeground(notificationId, notification)
                      isInForeground = true
                      Log.i(TAG, "üöå Foreground ÏÑúÎπÑÏä§ ÏãúÏûëÎê® (ID: $notificationId)")
                 } catch (e: Exception) {
                      Log.e(TAG, "üö® Foreground ÏÑúÎπÑÏä§ ÏãúÏûë Ïò§Î•ò: ${e.message}", e)
                      stopTrackingForRoute(routeId, monitoredRoutes[routeId]?.first, busNo)
                 }
            } else {
                 notificationManager.notify(notificationId, notification)
                 Log.d(TAG, "üöå Ongoing ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏Îê® (ID: $notificationId)")
            }
        } catch (e: Exception) {
            Log.e(TAG, "üöå Ongoing ÏïåÎ¶º ÏÉùÏÑ±/ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: ${e.message}")
            if (routeId != null) {
                 stopTrackingForRoute(routeId, monitoredRoutes[routeId]?.first, busNo)
            }
        }
    }

    fun showBusArrivingSoon(busNo: String, stationName: String, currentStation: String? = null) {
        Log.d(TAG, "üîî showBusArrivingSoon Ìò∏Ï∂úÎê® -> showBusArrivalNotification ÏÇ¨Ïö©")
        showBusArrivalNotification(stationName, busNo, 0)
        serviceScope.launch {
             val ttsMessage = "$busNo Î≤ÑÏä§Í∞Ä Ïù¥Ï†Ñ Ï†ïÎ•òÏû•Ïóê ÎèÑÏ∞©ÌñàÏäµÎãàÎã§. $stationName Ïóê Í≥ß ÎèÑÏ∞©Ìï©ÎãàÎã§. ÌïòÏ∞® Ï§ÄÎπÑÌïòÏÑ∏Ïöî."
             speakTts(ttsMessage, earphoneOnly = false)
        }
    }

    fun startTtsTracking(routeId: String, stationId: String, busNo: String, stationName: String) {
        if (!isTtsInitialized || ttsEngine == null) {
             Log.e(TAG, "üîä TTS Ï∂îÏ†Å ÏãúÏûë Î∂àÍ∞Ä - Ï¥àÍ∏∞Ìôî ÏïàÎê®")
             initializeTts()
             return
        }
        if (!::busApiService.isInitialized) {
             Log.e(TAG,"üîä TTS Ï∂îÏ†Å ÏãúÏûë Î∂àÍ∞Ä - BusApiService Ï¥àÍ∏∞Ìôî ÏïàÎê®")
             return
        }
        if (!useTextToSpeech) {
            Log.d(TAG, "üîä TTS ÏÑ§Ï†ï ÎπÑÌôúÏÑ±Ìôî - TTS Ï∂îÏ†Å ÏãúÏûë Ïïà Ìï®.")
            return
        }
        if (ttsJob?.isActive == true) {
            Log.d(TAG, "üîä Í∏∞Ï°¥ TTS Ï∂îÏ†Å ÏûëÏóÖ Ï§ëÏßÄ ÏãúÎèÑ")
            stopTtsTracking(routeId = routeId, stationId = stationId, forceStop = true)
        }
        val notificationKey = "${routeId}_${stationId}_$busNo"
        arrivingSoonNotified.remove(notificationKey)
        Log.d(TAG, "üîä ÏÉà TTS Ï∂îÏ†Å ÏãúÏûë, '$notificationKey' Í≥ß ÎèÑÏ∞© ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞Ìôî")

        isTtsTrackingActive = true
        ttsJob = serviceScope.launch {
            Log.i(TAG, "üîä TTS Ï∂îÏ†Å ÏãúÏûë: Bus=$busNo ($routeId), Station=$stationName ($stationId)")
            while (isTtsTrackingActive && isActive) {
                 var ttsMessage: String? = null
                 var shouldTriggerArrivingSoon = false
                 var currentBusNoForSoon = busNo
                 var currentStationForSoon = "Ï†ïÎ≥¥ ÏóÜÏùå"
                 var remainingStopsForSoon = -1
                 var apiError = false
                 try {
                     if (!useTextToSpeech) {
                         Log.d(TAG, "üîä TTS Ï∂îÏ†Å Ï§ë ÏÑ§Ï†ï ÎπÑÌôúÏÑ±Ìôî Í∞êÏßÄ. Î£®ÌîÑ Ï§ëÏßÄ.")
                         break
                     }
                     val arrivalInfoResult = withContext(Dispatchers.IO) {
                         try {
                             Log.d(TAG, "üöå [TTS API] Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë... ($routeId @ $stationId)")
                             busApiService.getBusArrivalInfoByRouteId(stationId, routeId)
                         } catch (e: Exception) {
                              Log.e(TAG, "‚ùå [TTS API] Ï†ïÎ≥¥ Ï°∞Ìöå Ïò§Î•ò: ${e.message}")
                              null
                         }
                     }
                     if (arrivalInfoResult == null) {
                          apiError = true
                          ttsMessage = "$busNo Î≤à Î≤ÑÏä§ Ï†ïÎ≥¥ Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§."
                     } else {
                         val firstBus = arrivalInfoResult.bus.firstOrNull { it.busNumber == busNo }
                         if (firstBus != null) {
                             val busInfo = BusInfo( busNumber = firstBus.busNumber, routeId = routeId,
                                 estimatedTime = firstBus.estimatedTime, currentStation = firstBus.currentStation,
                                 remainingStations = firstBus.remainingStations
                             )
                             val remainingMinutes = busInfo.getRemainingMinutes()
                             val currentStation = busInfo.currentStation ?: "Ï†ïÎ≥¥ ÏóÜÏùå"
                             val busStopCount = busInfo.remainingStations.replace("[^0-9]".toRegex(), "").toIntOrNull() ?: -1
                             currentBusNoForSoon = busNo
                             currentStationForSoon = currentStation
                             remainingStopsForSoon = busStopCount
                             ttsMessage = generateTtsMessage(busNo, stationName, remainingMinutes, currentStation, busStopCount)
                             shouldTriggerArrivingSoon = (busStopCount == 1 && remainingMinutes in 0..3)
                             Log.d(TAG,"üîä [TTS] Ï≤òÎ¶¨ ÏôÑÎ£å: Mins=$remainingMinutes, Stops=$busStopCount, Soon=$shouldTriggerArrivingSoon")
                         } else {
                             ttsMessage = "$busNo Î≤à Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§."
                             Log.d(TAG,"üîä [TTS] $busNo Î≤à Î≤ÑÏä§ Ï†ïÎ≥¥ ÏóÜÏùå (API Í≤∞Í≥º)")
                         }
                     }
                     if (ttsMessage != null) {
                         speakTts(ttsMessage, earphoneOnly = false)
                         if (shouldTriggerArrivingSoon) {
                             val notifyKey = "${routeId}_${stationId}_$currentBusNoForSoon"
                             if (arrivingSoonNotified.add(notifyKey)) {
                                 Log.i(TAG, "‚úÖ [TTS] 'Í≥ß ÎèÑÏ∞©' Ï°∞Í±¥ ÎßåÏ°± & Ï≤´ ÏïåÎ¶º Î∞úÎèô: $notifyKey")
                                 showBusArrivingSoon(currentBusNoForSoon, stationName, currentStationForSoon)
                                 break
                             } else {
                                 Log.d(TAG, "‚òëÔ∏è [TTS] 'Í≥ß ÎèÑÏ∞©' Ï°∞Í±¥ ÎßåÏ°±ÌñàÏúºÎÇò Ïù¥ÎØ∏ ÏïåÎ¶º: $notifyKey")
                             }
                         }
                     }
                     if (apiError) delay(60_000)
                     else delay(30_000)
                 } catch (e: CancellationException) {
                     Log.d(TAG, "üîä TTS Ï∂îÏ†Å ÏûëÏóÖ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∑®ÏÜåÎê® ($busNo @ $stationName)")
                     break
                 } catch (e: Exception) {
                     Log.e(TAG, "‚ùå TTS Ï∂îÏ†Å Î£®ÌîÑ ÎÇ¥ Ïò§Î•ò: ${e.message}", e)
                     delay(15_000)
                 }
            }
            Log.i(TAG, "üîä TTS Ï∂îÏ†Å Î£®ÌîÑ Ï¢ÖÎ£å: Bus=$busNo ($routeId), Station=$stationName ($stationId)")
            isTtsTrackingActive = false
            ttsJob = null
        }
    }

    fun cancelNotification(id: Int) {
        try {
            // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            val context = getAppContext()
            NotificationManagerCompat.from(context).cancel(id)
            Log.d(TAG, "üîî ÏïåÎ¶º Ï∑®ÏÜå ÏôÑÎ£å (ID: $id)")
        } catch (e: Exception) {
            Log.e(TAG, "üîî ÏïåÎ¶º Ï∑®ÏÜå Ïò§Î•ò (ID: $id): ${e.message}", e)
        }
    }

    fun cancelOngoingTracking() {
        Log.d(TAG,"cancelOngoingTracking Ìò∏Ï∂úÎê® (ID: $ONGOING_NOTIFICATION_ID)")
        try {
            // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            val context = getAppContext()
            NotificationManagerCompat.from(context).cancel(ONGOING_NOTIFICATION_ID)
            Log.d(TAG,"Ongoing notification (ID: $ONGOING_NOTIFICATION_ID) Ï∑®ÏÜå ÏôÑÎ£å.")
            if (isInForeground) {
                Log.d(TAG, "Service is in foreground, calling stopForeground(true).")
                stopForeground(true)
                isInForeground = false
            }
        } catch (e: Exception) {
            Log.e(TAG, "üöå Ongoing ÏïåÎ¶º Ï∑®ÏÜå/Foreground Ï§ëÏßÄ Ïò§Î•ò: ${e.message}", e)
        }
    }

    fun cancelAllNotifications() {
        try {
            // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            val context = getAppContext()
            NotificationManagerCompat.from(context).cancelAll()
            Log.i(TAG, "üîî Î™®Îì† ÏïåÎ¶º Ï∑®ÏÜå ÏôÑÎ£å (cancelAllNotifications)")
            if (isInForeground) {
                stopForeground(true)
                isInForeground = false
                 Log.d(TAG,"Foreground ÏÑúÎπÑÏä§ Ï§ëÎã®Îê® (cancelAllNotifications)")
            }
        } catch (e: Exception) {
            Log.e(TAG, "üîî Î™®Îì† ÏïåÎ¶º Ï∑®ÏÜå Ïò§Î•ò: ${e.message}", e)
        }
    }

    fun stopTracking() {
        Log.i(TAG, "--- BusAlertService Ï†ÑÏ≤¥ Ï∂îÏ†Å Ï§ëÏßÄ ÏãúÏûë ---")
        serviceScope.launch {
             try {
                stopMonitoringTimer()
                stopTtsTracking(forceStop = true)
                monitoredRoutes.clear()
                cachedBusInfo.clear()
                arrivingSoonNotified.clear()
                Log.d(TAG, "Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† Î∞è Í¥ÄÎ†® Ï∫êÏãú/ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞ÌôîÎê®")
                cancelOngoingTracking()
                _methodChannel?.invokeMethod("onBusMonitoringStopped", null)
                Log.i(TAG,"Î™®Îì† ÏûëÏóÖ Ï§ëÏßÄÎê®. ÏÑúÎπÑÏä§Îäî Ïú†ÏßÄÎê®.")
                // stopSelf() Ìò∏Ï∂ú Ï†úÍ±∞ - ÏÑúÎπÑÏä§Î•º Ï¢ÖÎ£åÌïòÏßÄ ÏïäÍ≥† Ïú†ÏßÄ
             } catch (e: Exception) {
                 Log.e(TAG, "stopTracking Ï§ë Ïã¨Í∞ÅÌïú Ïò§Î•ò: ${e.message}", e)
                 // stopSelf() Ìò∏Ï∂ú Ï†úÍ±∞ - Ïò§Î•ò Î∞úÏÉùÌï¥ÎèÑ ÏÑúÎπÑÏä§ Ïú†ÏßÄ
             } finally {
                 Log.i(TAG, "--- BusAlertService Ï†ÑÏ≤¥ Ï∂îÏ†Å Ï§ëÏßÄ ÏôÑÎ£å ---")
             }
        }
    }

    fun stopTrackingForRoute(routeId: String?, stationId: String?, busNo: String?) {
         serviceScope.launch {
             if (routeId == null) {
                 Log.w(TAG, "stopTrackingForRoute Ìò∏Ï∂úÎê® - routeId ÏóÜÏùå, Ï§ëÎã®.")
                 return@launch
             }
             Log.i(TAG, "stopTrackingForRoute ÏãúÏûë: Route=$routeId, Station=$stationId, Bus=$busNo")
             // TTS Ï∂îÏ†Å Ï§ëÏßÄ
             stopTtsTracking(routeId = routeId, stationId = stationId, forceStop = true)

             // Ìè¨Í∑∏ÎùºÏö¥Îìú ÏïåÎ¶º Ï∑®ÏÜå - Ïó¨Í∏∞ÏÑú Ï∂îÍ∞Ä
             cancelOngoingTracking()
             Log.d(TAG, "Ìè¨Í∑∏ÎùºÏö¥Îìú ÏïåÎ¶º Ï∑®ÏÜå ÏôÑÎ£å (stopTrackingForRoute)")
             // Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ† Ï†úÍ±∞
             val removedRouteInfo = monitoredRoutes.remove(routeId)
             if (removedRouteInfo != null) {
                 Log.d(TAG, "Î™®ÎãàÌÑ∞ÎßÅ Î™©Î°ùÏóêÏÑú $routeId Ï†úÍ±∞Îê® (Station: ${removedRouteInfo.first})")
             } else {
                 Log.d(TAG, "Î™®ÎãàÌÑ∞ÎßÅ Î™©Î°ùÏóê $routeId ÏóÜÏùå")
             }
             // ÎèÑÏ∞© ÏûÑÎ∞ï ÌîåÎûòÍ∑∏ Ï†úÍ±∞
             if (stationId != null && busNo != null) {
                  val notificationKey = "${routeId}_${stationId}_$busNo"
                  if (arrivingSoonNotified.remove(notificationKey)) {
                      Log.d(TAG, "'Í≥ß ÎèÑÏ∞©' ÌîåÎûòÍ∑∏ Ï†úÍ±∞Îê®: $notificationKey")
                  }
             }
             // Î™®ÎãàÌÑ∞ÎßÅ ÎÖ∏ÏÑ†Ïù¥ ÏóÜÏúºÎ©¥ Ï†ÑÏ≤¥ Ï∂îÏ†Å Ï§ëÏßÄ, ÏûàÏúºÎ©¥ ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏
             if (monitoredRoutes.isEmpty()) {
                 Log.i(TAG, "$routeId Ï†úÍ±∞ ÌõÑ ÎÇ®ÏùÄ ÎÖ∏ÏÑ† ÏóÜÏùå. Ï†ÑÏ≤¥ Ï∂îÏ†Å Ï§ëÏßÄ Ìò∏Ï∂ú.")
                 stopTracking()
             } else {
                 Log.i(TAG, "$routeId Ï†úÍ±∞ ÌõÑ ${monitoredRoutes.size}Í∞ú ÎÖ∏ÏÑ† ÎÇ®Ïùå. ÏïåÎ¶º ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî.")
                 checkBusArrivals()
             }
         }
    }

    fun stopTtsTracking(forceStop: Boolean = false, routeId: String? = null, stationId: String? = null) {
        serviceScope.launch {
            if (!isTtsTrackingActive && !forceStop) {
                Log.d(TAG, "üîä TTS Ï∂îÏ†ÅÏù¥ Ïù¥ÎØ∏ Ï§ëÏßÄÎêú ÏÉÅÌÉúÏûÖÎãàÎã§ (forceStop=false).")
                return@launch
            }
            Log.d(TAG, "üîä TTS Ï∂îÏ†Å Ï§ëÏßÄ ÏãúÎèÑ (forceStop=$forceStop, routeId=$routeId, stationId=$stationId)")
            try {
                if (ttsJob?.isActive == true) {
                    ttsJob?.cancel(CancellationException("TTS Ï∂îÏ†Å Ï§ëÏßÄ ÏöîÏ≤≠Îê® (stopTtsTracking)"))
                    Log.d(TAG, "üîä TTS ÏΩîÎ£®Ìã¥ ÏûëÏóÖ Ï∑®ÏÜåÎê®")
                }
                ttsJob = null
                if (isTtsInitialized && ttsEngine != null) {
                     ttsEngine?.stop()
                     Log.d(TAG, "üîä TTS ÏóîÏßÑ stop() Ìò∏Ï∂úÎê®")
                     audioManager?.abandonAudioFocus(audioFocusListener)
                }
                isTtsTrackingActive = false
                Log.d(TAG, "üîä isTtsTrackingActive ÌîåÎûòÍ∑∏ falseÎ°ú ÏÑ§Ï†ïÎê®")
                 if (routeId != null && stationId != null) {
                     val prefixKey = "${routeId}_${stationId}"
                     val keysToRemove = arrivingSoonNotified.filter { it.startsWith(prefixKey) }
                     if (keysToRemove.isNotEmpty()) {
                         arrivingSoonNotified.removeAll(keysToRemove)
                         Log.d(TAG, "üîä TTS Ï∂îÏ†Å Ï§ëÏßÄ, '$prefixKey' Í¥ÄÎ†® 'Í≥ß ÎèÑÏ∞©' ÏïåÎ¶º ÌîåÎûòÍ∑∏ Ï†úÍ±∞Îê® (${keysToRemove.size}Í∞ú)")
                     }
                 }
                Log.i(TAG, "üîä TTS Ï∂îÏ†Å Ï§ëÏßÄ ÏôÑÎ£å (forceStop: $forceStop)")
            } catch (e: Exception) {
                Log.e(TAG, "‚ùå TTS Ï∂îÏ†Å Ï§ëÏßÄ Ïò§Î•ò: ${e.message}", e)
                isTtsTrackingActive = false
                ttsJob = null
            }
        }
    }

    override fun onDestroy() {
        Log.i(TAG, "üîî BusAlertService onDestroy ÏãúÏûë")
        serviceScope.launch { // Ensure cleanup runs on main scope
             // ÏÑúÎπÑÏä§ Ï¢ÖÎ£å Ïãú Ï∂îÏ†Å Ï§ëÏßÄÎßå ÌïòÍ≥† ÏûêÏõê Ìï¥Ï†ú
             stopMonitoringTimer()
             stopTtsTracking(forceStop = true)
             cancelOngoingTracking()

             // TTS ÏûêÏõê Ìï¥Ï†ú
             ttsEngine?.stop()
             ttsEngine?.shutdown()
             ttsEngine = null
             isTtsInitialized = false

             // Ïù∏Ïä§ÌÑ¥Ïä§ Ïú†ÏßÄ - ÏÑúÎπÑÏä§Í∞Ä Ïû¨ÏãúÏûëÎê† Îïå ÏÇ¨Ïö©ÌïòÍ∏∞ ÏúÑÌï¥
             // instance = null

             Log.d(TAG,"TTS ÏóîÏßÑ Ï¢ÖÎ£å Î∞è ÏûêÏõê Ìï¥Ï†ú ÏôÑÎ£å")
        }.invokeOnCompletion {
             serviceScope.cancel() // Cancel the scope itself after cleanup
             super.onDestroy()
             Log.i(TAG, "üîî BusAlertService onDestroy ÏôÑÎ£å")
        }
    }

    fun getCachedBusInfo(busNo: String, routeId: String): BusInfo? {
        val cacheKey = "$busNo-$routeId"
        val cachedInfo = cachedBusInfo[cacheKey]
        if (cachedInfo != null) {
            val lastUpdateTime = cachedInfo.lastUpdateTime ?: 0L
            val currentTime = System.currentTimeMillis()
            val elapsedMinutes = (currentTime - lastUpdateTime) / (1000 * 60)
            val cacheValidityMinutes = 2
            if (elapsedMinutes > cacheValidityMinutes) {
                Log.d(TAG, "üöå Ï∫êÏãú ÎßåÎ£åÎê® ($elapsedMinutes Î∂Ñ Í≤ΩÍ≥º): $cacheKey")
                cachedBusInfo.remove(cacheKey)
                return null
            }
            Log.d(TAG,"üöå Ïú†Ìö®Ìïú Ï∫êÏãú ÏÇ¨Ïö© ($elapsedMinutes Î∂Ñ Ï†Ñ): $cacheKey")
            return cachedInfo
        }
        return null
    }

    private fun loadSettings() {
        try {
            // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            val context = getAppContext()
            val prefs = context.getSharedPreferences("bus_alert_settings", Context.MODE_PRIVATE)
            currentAlarmSound = prefs.getString(PREF_ALARM_SOUND_FILENAME, DEFAULT_ALARM_SOUND) ?: DEFAULT_ALARM_SOUND
            useTextToSpeech = prefs.getBoolean(PREF_ALARM_USE_TTS, true)
            audioOutputMode = prefs.getInt(PREF_SPEAKER_MODE, OUTPUT_MODE_AUTO)
            notificationDisplayMode = prefs.getInt(PREF_NOTIFICATION_DISPLAY_MODE_KEY, DISPLAY_MODE_ALARMED_ONLY)
            ttsVolume = prefs.getFloat(PREF_TTS_VOLUME, 1.0f).coerceIn(0f, 1f)
            Log.d(TAG, "‚öôÔ∏è ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å - TTS: $useTextToSpeech, ÏïåÎûåÏùå: $currentAlarmSound, Î™®Îìú: $notificationDisplayMode, Ï∂úÎ†•: $audioOutputMode, Î≥ºÎ•®: ${ttsVolume * 100}%")
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                  val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                  updateChannelSound(notificationManager, CHANNEL_BUS_ALERTS)
             }
        } catch (e: Exception) {
            Log.e(TAG, "‚öôÔ∏è ÏÑ§Ï†ï Î°úÎìú Ï§ë Ïò§Î•ò: ${e.message}")
        }
    }

    fun setAlarmSound(filename: String, useTts: Boolean = false) {
         serviceScope.launch {
             try {
                 currentAlarmSound = filename.ifBlank { "" }
                 useTextToSpeech = useTts
                 // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                 val context = getAppContext()
                 val sharedPreferences = context.getSharedPreferences("bus_alert_settings", Context.MODE_PRIVATE)
                 sharedPreferences.edit()
                    .putString(PREF_ALARM_SOUND_FILENAME, currentAlarmSound)
                    .putBoolean(PREF_ALARM_USE_TTS, useTextToSpeech)
                    .apply()
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                    val context = getAppContext()
                    val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                    updateChannelSound(notificationManager, CHANNEL_BUS_ALERTS)
                 }
                 Log.i(TAG, "üîî ÏïåÎûåÏùå ÏÑ§Ï†ï Ï†ÄÏû•Îê®: '$currentAlarmSound', TTS ÏÇ¨Ïö©: $useTextToSpeech")
             } catch (e: Exception) {
                 Log.e(TAG, "üîî ÏïåÎûåÏùå ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
             }
         }
    }

    fun setAudioOutputMode(mode: Int) {
         serviceScope.launch {
             try {
                if (mode in OUTPUT_MODE_HEADSET..OUTPUT_MODE_AUTO) {
                    audioOutputMode = mode
                    // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                    val context = getAppContext()
                    val prefs = context.getSharedPreferences("bus_alert_settings", Context.MODE_PRIVATE)
                    prefs.edit().putInt(PREF_SPEAKER_MODE, audioOutputMode).apply()
                    Log.i(TAG, "üîî Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÑ§Ï†ï Ï†ÄÏû•Îê®: $audioOutputMode")
                } else {
                    Log.e(TAG, "üîî ÏûòÎ™ªÎêú Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú Í∞í: $mode")
                }
             } catch (e: Exception) {
                 Log.e(TAG, "üîî Ïò§ÎîîÏò§ Ï∂úÎ†• Î™®Îìú ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
             }
         }
    }

    fun getAudioOutputMode(): Int = audioOutputMode

    private fun isHeadsetConnected(): Boolean {
        if (audioManager == null) {
             Log.w(TAG,"AudioManager null in isHeadsetConnected")
             return false
        }
        try {
             val isWired = audioManager?.isWiredHeadsetOn ?: false
             val isA2dp = audioManager?.isBluetoothA2dpOn ?: false
             val isSco = audioManager?.isBluetoothScoOn ?: false
             val isConnected = isWired || isA2dp || isSco
             Log.d(TAG, "üéß Ïù¥Ïñ¥Ìè∞ Ïó∞Í≤∞ ÏÉÅÌÉú: Ïú†ÏÑ†=$isWired, BT(A2DP)=${isA2dp}, BT(SCO)=${isSco} -> Ïó∞Í≤∞Îê®=$isConnected")
            return isConnected
        } catch (e: Exception) {
            Log.e(TAG, "üéß Ïù¥Ïñ¥Ìè∞ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò: ${e.message}", e)
            return false
        }
    }

    fun speakTts(text: String, earphoneOnly: Boolean = false) {
        if (!isTtsInitialized || ttsEngine == null) {
             Log.e(TAG, "üîä TTS Î∞úÌôî Î∂àÍ∞Ä - ÏóîÏßÑ Ï¥àÍ∏∞Ìôî ÏïàÎê®")
             initializeTts()
             return
        }
        if (!useTextToSpeech) {
            Log.d(TAG, "üîä TTS ÏÑ§Ï†ï ÎπÑÌôúÏÑ±ÌôîÎê®. Î∞úÌôî Í±¥ÎÑàÎúÄ.")
            return
        }
        if (text.isBlank()) {
             Log.w(TAG, "üîä TTS Î∞úÌôî Î∂àÍ∞Ä - Î©îÏãúÏßÄ ÎπÑÏñ¥ÏûàÏùå")
             return
        }
        serviceScope.launch {
             try {
                val message = text
                if (audioManager == null) audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
                val isHeadsetConnected = isHeadsetConnected()
                val useSpeaker = when (audioOutputMode) {
                    OUTPUT_MODE_SPEAKER -> true
                    OUTPUT_MODE_HEADSET -> false
                    OUTPUT_MODE_AUTO -> !isHeadsetConnected
                    else -> !isHeadsetConnected
                }
                val streamType = if (useSpeaker) AudioManager.STREAM_ALARM else AudioManager.STREAM_MUSIC
                Log.d(TAG, "üîä TTS Î∞úÌôî Ï§ÄÎπÑ: Stream=${if(streamType == AudioManager.STREAM_ALARM) "ALARM" else "MUSIC"}, Ïä§ÌîºÏª§ÏÇ¨Ïö©=$useSpeaker, Î≥ºÎ•®=${ttsVolume * 100}%")
                val utteranceId = "tts_${System.currentTimeMillis()}"
                val params = Bundle().apply {
                    putString(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID, utteranceId)
                    putInt(TextToSpeech.Engine.KEY_PARAM_STREAM, streamType)
                    putFloat(TextToSpeech.Engine.KEY_PARAM_VOLUME, ttsVolume)
                }
                val focusResult: Int
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                     val audioAttributes = AudioAttributes.Builder()
                        .setUsage(if (useSpeaker) AudioAttributes.USAGE_ALARM else AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY)
                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                        .build()
                     val focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)
                        .setAudioAttributes(audioAttributes)
                        .setAcceptsDelayedFocusGain(true)
                        .setOnAudioFocusChangeListener(audioFocusListener)
                        .build()
                     focusResult = audioManager?.requestAudioFocus(focusRequest) ?: AudioManager.AUDIOFOCUS_REQUEST_FAILED
                } else {
                     @Suppress("DEPRECATION")
                     focusResult = audioManager?.requestAudioFocus(
                        audioFocusListener, streamType, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT
                     ) ?: AudioManager.AUDIOFOCUS_REQUEST_FAILED
                }
                if (focusResult == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
                    Log.d(TAG, "üîä Ïò§ÎîîÏò§ Ìè¨Ïª§Ïä§ ÌöçÎìù ÏÑ±Í≥µ. TTS Î∞úÌôî ÏãúÏûë.")
                    ttsEngine?.setOnUtteranceProgressListener(createTtsListener())
                    ttsEngine?.speak(message, TextToSpeech.QUEUE_FLUSH, params, utteranceId)
                } else {
                    Log.e(TAG, "üîä Ïò§ÎîîÏò§ Ìè¨Ïª§Ïä§ ÌöçÎìù Ïã§Ìå® ($focusResult). TTS Î∞úÌôî Ï∑®ÏÜå.")
                }
             } catch (e: Exception) {
                 Log.e(TAG, "‚ùå TTS Î∞úÌôî Ï§ë Ïò§Î•ò Î∞úÏÉù: ${e.message}", e)
                 audioManager?.abandonAudioFocus(audioFocusListener)
             }
        }
    }

    private fun generateTtsMessage(busNo: String, stationName: String, remainingMinutes: Int?, currentStation: String?, remainingStops: Int?): String {
         return when {
             remainingMinutes == null || remainingMinutes < 0 -> "$busNo Î≤à Î≤ÑÏä§ ÎèÑÏ∞© Ï†ïÎ≥¥Î•º Ïïå Ïàò ÏóÜÏäµÎãàÎã§."
             remainingStops == 1 && (remainingMinutes) in 0..3 -> "$busNo Î≤ÑÏä§Í∞Ä Ïù¥Ï†Ñ Ï†ïÎ•òÏû•Ïóê ÎèÑÏ∞©ÌñàÏäµÎãàÎã§. $stationName Ïóê Í≥ß ÎèÑÏ∞©ÌïòÎãà ÌïòÏ∞® Ï§ÄÎπÑÌïòÏÑ∏Ïöî."
             remainingMinutes == 0 -> "$busNo Î≤ÑÏä§Í∞Ä $stationName Ïóê ÎèÑÏ∞©ÌñàÏäµÎãàÎã§. ÌïòÏ∞®ÌïòÏÑ∏Ïöî."
             else -> {
                 val locationInfo = if (!currentStation.isNullOrEmpty() && currentStation != "Ï†ïÎ≥¥ ÏóÜÏùå") " ÌòÑÏû¨ $currentStation" else ""
                 "$busNo Î≤ÑÏä§Í∞Ä$locationInfo ÏóêÏÑú Ï∂úÎ∞úÌïòÏó¨, $stationName Ïóê ÏïΩ ${remainingMinutes}Î∂Ñ ÌõÑ ÎèÑÏ∞© ÏòàÏ†ïÏûÖÎãàÎã§."
             }
        }
    }

    private fun formatAllArrivalsForNotification(arrivals: List<Triple<String, String, BusInfo>>): String {
        if (arrivals.isEmpty()) return "ÎèÑÏ∞© ÏòàÏ†ï Î≤ÑÏä§ Ï†ïÎ≥¥Í∞Ä ÏóÜÏäµÎãàÎã§."
        val soonestPerRoute = arrivals
            .groupBy { it.first }
            .mapValues { (_, busList) -> busList.minByOrNull { it.third.getRemainingMinutes().let { t -> if (t < 0) Int.MAX_VALUE else t} } }
            .values.filterNotNull()
            .sortedBy { it.third.getRemainingMinutes().let { t -> if (t < 0) Int.MAX_VALUE else t} }
        return buildString {
            val displayCount = min(soonestPerRoute.size, 4)
            for (i in 0 until displayCount) {
                val (busNo, _, busInfo) = soonestPerRoute[i]
                val timeStr = busInfo.estimatedTime
                append("${busNo}Î≤à: $timeStr")
                if (i < displayCount - 1) append("\n")
            }
            if (soonestPerRoute.size > displayCount) {
                if (displayCount > 0) append("\n")
                append("Ïô∏ ${soonestPerRoute.size - displayCount}ÎåÄ Îçî ÏûàÏùå")
            }
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
         if (!::busApiService.isInitialized) { // Ensure critical components are ready
            Log.w(TAG, "onStartCommand: BusApiService Ïû¨Ï¥àÍ∏∞Ìôî ÏãúÎèÑ")
            busApiService = BusApiService(this)
         }

        val action = intent?.action
        Log.i(TAG, "onStartCommand ÏàòÏã†: Action=$action, StartId=$startId")
        serviceScope.launch {
            try {
                 when (action) {
                    ACTION_START_TRACKING_FOREGROUND, ACTION_UPDATE_TRACKING -> {
                        val busNo = intent.getStringExtra("busNo") ?: ""
                        val stationName = intent.getStringExtra("stationName") ?: ""
                        val remainingMinutes = intent.getIntExtra("remainingMinutes", -1)
                        val currentStation = intent.getStringExtra("currentStation")
                        val isUpdate = action == ACTION_UPDATE_TRACKING
                        val allBusesSummary = intent.getStringExtra("allBusesSummary")
                        val routeId = intent.getStringExtra("routeId")
                        val stationId = intent.getStringExtra("stationId")
                        if (routeId == null || busNo.isBlank() || stationName.isBlank()) {
                             Log.e(TAG, "$action Ï≤òÎ¶¨ Ï§ëÎã®: ÌïÑÏàò Ï†ïÎ≥¥ Î∂ÄÏ°±")
                             stopTrackingIfIdle()
                             return@launch
                        }
                        if (action == ACTION_START_TRACKING_FOREGROUND) {
                             if (!stationId.isNullOrBlank()) {
                                 addMonitoredRoute(routeId, stationId, stationName)
                             } else {
                                  Log.w(TAG, "Î™®ÎãàÌÑ∞ÎßÅ Ï∂îÍ∞Ä Í±¥ÎÑàÎúÄ - $routeId @ $stationName (StationID ÏóÜÏùå)")
                             }
                        }
                        showOngoingBusTracking(
                            busNo = busNo, stationName = stationName, remainingMinutes = remainingMinutes,
                            currentStation = currentStation, isUpdate = isUpdate,
                            notificationId = ONGOING_NOTIFICATION_ID, allBusesSummary = allBusesSummary,
                            routeId = routeId
                        )
                    }
                    ACTION_STOP_BUS_ALERT_TRACKING -> {
                         val routeId = intent.getStringExtra("routeId")
                         val stationId = intent.getStringExtra("stationId")
                         val busNo = intent.getStringExtra("busNo")
                         val stationName = intent.getStringExtra("stationName")
                         Log.i(TAG, "ÏïåÎ¶º Action '$action' ÏàòÏã†: Route=$routeId, Station=$stationId, Bus=$busNo, StationName=$stationName")

                         // Flutter Ï∏°Ïóê ÏïåÎûå Ï∑®ÏÜå ÏïåÎ¶º Ï†ÑÏÜ°
                         if (busNo != null && routeId != null) {
                             try {
                                 val alarmCancelData = mapOf(
                                     "busNo" to busNo,
                                     "routeId" to routeId,
                                     "stationName" to (stationName ?: "")
                                 )
                                 // Î©îÏù∏ Î©îÏÑúÎìú Ï±ÑÎÑêÎ°ú Ï†ÑÏÜ°
                                 _methodChannel?.invokeMethod("onAlarmCanceledFromNotification", alarmCancelData)
                                 Log.i(TAG, "Flutter Ï∏°Ïóê ÏïåÎûå Ï∑®ÏÜå ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å: $busNo, $routeId")

                                 // Ïï± Ïª®ÌÖçÏä§Ìä∏Î•º ÌÜµÌï¥ Ïù¥Î≤§Ìä∏ Î∞úÏÉù
                                 val intent = Intent("com.example.daegu_bus_app.ALARM_CANCELED")
                                 intent.putExtra("busNo", busNo)
                                 intent.putExtra("routeId", routeId)
                                 intent.putExtra("stationName", stationName ?: "")
                                 applicationContext.sendBroadcast(intent)
                                 Log.i(TAG, "Broadcast Ïù¥Î≤§Ìä∏ Î∞úÏÉù: ALARM_CANCELED")
                             } catch (e: Exception) {
                                 Log.e(TAG, "Flutter Ï∏°Ïóê ÏïåÎûå Ï∑®ÏÜå ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò: ${e.message}")
                             }
                         }

                         // Ï∂îÏ†Å Ï§ëÏßÄ Ïã§Ìñâ
                         stopTrackingForRoute(routeId, stationId, busNo)
                    }
                    else -> {
                         Log.w(TAG, "Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Action ÏàòÏã†: $action")
                          stopTrackingIfIdle()
                    }
                 }
            } catch (e: Exception) {
                 Log.e(TAG, "onStartCommand Action Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò (Action: $action): ${e.message}", e)
                 stopTrackingIfIdle()
            }
        }
        return START_STICKY
    }

     private fun stopTrackingIfIdle() {
         serviceScope.launch {
             if (monitoredRoutes.isEmpty() && !isTtsTrackingActive) {
                 Log.i(TAG, "ÏÑúÎπÑÏä§ Ïú†Ìú¥ ÏÉÅÌÉú Í∞êÏßÄ. Ï†ÑÏ≤¥ Ï∂îÏ†Å Ï§ëÏßÄ Ìò∏Ï∂ú.")
                 stopTracking()
             } else {
                  Log.d(TAG,"ÏÑúÎπÑÏä§ Ïú†Ìú¥ ÏÉÅÌÉú ÏïÑÎãò (Î™®ÎãàÌÑ∞ÎßÅ: ${monitoredRoutes.size}, TTS: $isTtsTrackingActive).")
             }
         }
     }

    fun setTtsVolume(volume: Double) {
        serviceScope.launch {
            try {
                ttsVolume = volume.toFloat().coerceIn(0f, 1f)
                // Ïª®ÌÖçÏä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
                val context = getAppContext()
                val prefs = context.getSharedPreferences("bus_alert_settings", Context.MODE_PRIVATE)
                prefs.edit().putFloat(PREF_TTS_VOLUME, ttsVolume).apply()
                Log.i(TAG, "üîä TTS Î≥ºÎ•® ÏÑ§Ï†ïÎê®: ${ttsVolume * 100}%")
            } catch (e: Exception) {
                Log.e(TAG, "üîä TTS Î≥ºÎ•® ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}", e)
            }
        }
    }

} // End of BusAlertService class


class NotificationDismissReceiver : android.content.BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        val notificationId = intent.getIntExtra("NOTIFICATION_ID", -1)
        if (notificationId != -1) {
            Log.d("NotificationDismiss", "üîî ÏùºÎ∞ò ÏïåÎ¶º Ìï¥Ï†úÎê® (ID: $notificationId)")
        }
    }
}

fun getNotificationChannels(context: Context): List<NotificationChannel>? {
    return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val notificationManager =
            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager?
        notificationManager?.notificationChannels
    } else {
        null
    }
}

fun BusAlertService.BusInfo.toMap(): Map<String, Any?> {
    val isLowFloor = false
    val isOutOfService = estimatedTime == "Ïö¥ÌñâÏ¢ÖÎ£å"
    return mapOf(
        "busNumber" to busNumber, "routeId" to routeId, "estimatedTime" to estimatedTime,
        "currentStation" to currentStation, "remainingStations" to remainingStations,
        "lastUpdateTime" to lastUpdateTime, "isLowFloor" to isLowFloor,
        "isOutOfService" to isOutOfService, "remainingMinutes" to getRemainingMinutes()
    )
}

fun StationArrivalOutput.BusInfo.toMap(): Map<String, Any?> {
    return mapOf(
        "busNumber" to busNumber, "currentStation" to currentStation,
        "remainingStations" to remainingStations, "estimatedTime" to estimatedTime
    )
}

fun StationArrivalOutput.toMap(): Map<String, Any?> {
    return mapOf(
        "name" to name, "sub" to sub, "id" to id, "forward" to forward,
        "bus" to bus.map { it.toMap() }
    )
}

fun RouteStation.toMap(): Map<String, Any?> {
    return mapOf(
        "stationId" to stationId, "stationName" to stationName,
        "sequenceNo" to sequenceNo, "direction" to direction
    )
}